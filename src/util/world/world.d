// Written in D programming language
/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module util.world.world;

import derelict.tcod.libtcod;
import std.container;
import std.conv;
import std.math;
import std.stdio;
import std.string;

import util.log;

public
{
	// size of the heightmap
	enum HM_WIDTH = 800;
	enum HM_HEIGHT = 800;

	// biome and climate list. based on Whittaker Biome Diagram
	enum EClimate 
	{
	    ARTIC_ALPINE,
	    COLD,
	    TEMPERATE,
	    WARM,
	    TROPICAL,
	    NB_CLIMATES
	};

	// grassland : might be either grassland, shrubland or woodland depending on the vegetation level
	// savanna : might be either savanna or thorn forest depending on the vegetation level
	enum EBiome 
	{
		TUNDRA,
	    COLD_DESERT, GRASSLAND, BOREAL_FOREST,
	    TEMPERATE_FOREST, TROPICAL_MONTANE_FOREST,
	    HOT_DESERT, SAVANNA, TROPICAL_DRY_FOREST, TROPICAL_EVERGREEN_FOREST,
	    THORN_FOREST,
	    NB_BIOMES
	};	

	static T clamp(T)(T min, T max, T val) pure nothrow
	{
		return val < min ? min : (val > max ? max : val);
	}	
}
package
{
	// temperature / precipitation Biome diagram (Whittaker diagram)
	EBiome biomeDiagram[5][5] = [
	    // artic/alpine climate (below -5°C)
	    [ EBiome.TUNDRA, EBiome.TUNDRA, EBiome.TUNDRA, EBiome.TUNDRA, EBiome.TUNDRA, ],
	    // cold climate (-5 / 5 °C)
	    [ EBiome.COLD_DESERT, EBiome.GRASSLAND, EBiome.BOREAL_FOREST, EBiome.BOREAL_FOREST, EBiome.BOREAL_FOREST, ],
	    // temperate climate (5 / 15 °C)
	    [ EBiome.COLD_DESERT, EBiome.GRASSLAND, EBiome.TEMPERATE_FOREST, EBiome.TEMPERATE_FOREST, EBiome.TROPICAL_MONTANE_FOREST, ],
	    // warm climate (15 - 20°C)
	    [ EBiome.HOT_DESERT, EBiome.SAVANNA, EBiome.TROPICAL_DRY_FOREST, EBiome.TROPICAL_EVERGREEN_FOREST, EBiome.TROPICAL_EVERGREEN_FOREST, ],
	    // tropical climate (above 20 °C)
	    [ EBiome.HOT_DESERT, EBiome.THORN_FOREST, EBiome.TROPICAL_DRY_FOREST, EBiome.TROPICAL_EVERGREEN_FOREST, EBiome.TROPICAL_EVERGREEN_FOREST, ],
	];

	enum sandHeight		=	0.12f;
	enum grassHeight	=	0.16f; //0.315f;
	enum rockHeight		=	0.655f;
	enum snowHeight		=	0.905f; //0.785f;

	// TCOD's land color map
	enum MAX_COLOR_KEY	=	10;

	enum COLOR_KEY_MAX_SEA = 	(cast(int)(sandHeight*255)-1);
	enum COLOR_KEY_MIN_LAND = 	(cast(int)(sandHeight*255));

	static const int keyIndex[MAX_COLOR_KEY] = 
	[	
		0,
		COLOR_KEY_MAX_SEA,
		COLOR_KEY_MIN_LAND,
		cast(int)(grassHeight*255),
		cast(int)(grassHeight*255)+10,
		cast(int)(rockHeight*255),
		cast(int)(rockHeight*255)+10,
		cast(int)(snowHeight*255),
		cast(int)(snowHeight*255)+10,
		255
	];
	static const TCOD_color_t keyColor[MAX_COLOR_KEY] = 
	[
		TCOD_color_t(0,0,50),    	// deep water
		TCOD_color_t(20,20,200), 	// water-sand transition
		TCOD_color_t(134,180,101),	// sand
		TCOD_color_t(80,120,10),	// sand-grass transition
		TCOD_color_t(17,109,7), 	// grass
		TCOD_color_t(30,85,12), 	// grass-rock transisiton
		TCOD_color_t(64,70,20), 	// rock
		TCOD_color_t(120,140,40), 	// rock-snow transisiton
		TCOD_color_t(208,208,239),  // snow
		TCOD_color_t(255,255,255)
	];

	// altitude color map
	enum MAX_ALT_KEY	=	8;
	static const int altIndexes[MAX_ALT_KEY] = 
	[
		0,15,cast(int)(sandHeight*255),cast(int)(sandHeight*255)+1,
		80,130,195,255
	];
	static const float altitudes[MAX_ALT_KEY] = 
	[
	    -2000,-1000,-100,0,500,1000,2500,4000	// in meters
	];
	static const TCOD_color_t altColors[MAX_ALT_KEY] = 
	[
		TCOD_color_t(24,165,255), 	// -2000
		TCOD_color_t(132,214,255), 	// -1000
		TCOD_color_t(247,255,255), 	// -100
		TCOD_color_t(49,149,44), 	// 0
		TCOD_color_t(249,209,151), 	// 500
		TCOD_color_t(165,148,24), 	// 1000
		TCOD_color_t(153,110,6), 	// 2500
		TCOD_color_t(172,141,138), 	// 4000
	];

	// precipitation color map
	enum MAX_PREC_KEY	=	19;
	static const int precIndexes[MAX_PREC_KEY] = 
	[
		4,8,12,16,20,24,28,32,36,40,50,60,70,80,100,120,140,160,255
	];
	static const float precipitations[MAX_PREC_KEY] = 
	[
		0,1,2,3,4,5,6,7,8,9,10,13,15,18,20,25,30,35,40  // cm / m² / year
	];
	static const TCOD_color_t precColors[MAX_PREC_KEY]= 
	[
		TCOD_color_t(128,0,0), 		// < 4
		TCOD_color_t(173,55,0), 	// 4-8
		TCOD_color_t(227,102,0), 	// 8-12
		TCOD_color_t(255,149,0), 	// 12-16
		TCOD_color_t(255,200,0), 	// 16-20
		TCOD_color_t(255,251,0), 	// 20-24
		TCOD_color_t(191,255,0), 	// 24-28
		TCOD_color_t(106,251,0), 	// 28-32
		TCOD_color_t(25,255,48), 	// 32-36
		TCOD_color_t(48,255,141), 	// 36-40
		TCOD_color_t(28,255,232), 	// 40-50
		TCOD_color_t(54,181,255), 	// 50-60
		TCOD_color_t(41,71,191), 	// 60-70
		TCOD_color_t(38,0,255), 	// 70-80
		TCOD_color_t(140,0,255), 	// 80-100
		TCOD_color_t(221,0,255), 	// 100-120
		TCOD_color_t(255,87,255), 	// 120-140
		TCOD_color_t(255,173,255), 	// 140-160
		TCOD_color_t(255,206,255), 	// > 160
	];

	// temperature color map
	enum MAX_TEMP_KEY	=	7;
	static const int tempIndexes[MAX_TEMP_KEY] = [0,42,84,126,168,210,255];
	static const int temperatures[MAX_TEMP_KEY] = [-30,-20,-10,0,10,20,30];
	static const TCOD_color_t tempKeyColor[MAX_TEMP_KEY] = 
	[
		TCOD_color_t(180,8,130), 	// -30 °C
		TCOD_color_t(32,1,139), 	// -20 °C
		TCOD_color_t(0,65,252),		// -10 °C
		TCOD_color_t(37,255,236),	// 0 °C
		TCOD_color_t(255,255,1), 	// 10 °C
		TCOD_color_t(255,29,4), 	// 20 °C
		TCOD_color_t(80,3,0), 		// 30 °C
	];

	static bool inRectangle(int x, int y, int w, int h) pure nothrow
	{
		return (cast(uint)(x) < cast(uint)(w) && cast(uint)(y) < cast(uint)(h));
	}

	static double sqrdist(double x1, double y1, double x2, double y2)
	{
		return (((x1)-(x2))*((x1)-(x2))+((y1)-(y2))*((y1)-(y2)));
	}	

	void genLog(T...)(T args)
	{
		writeNoticeLog(text(args));
	}

}
private
{
	static const int dirx[9] = [ 0, -1,0,1,-1,1,-1,0,1 ];
	static const int diry[9] = [ 0, -1,-1,-1,0,0,1,1,1 ];
	static const float dircoef[9] =  [1.0f, 1.0f/1.414f, 1.0f, 1.0f/1.414f,1.0f,1.0f,1.0f/1.414f, 1.0f,1.0f/1.414f ];
	static const int oppdir[9] = [0, 8, 7, 6, 5, 4, 3, 2, 1 ];

	// erosion parameters
	enum EROSION_FACTOR  		= 0.01f;
	enum SEDIMENTATION_FACTOR 	= 0.01f;
	enum MAX_EROSION_ALT 		= 0.9f;
	enum MUDSLIDE_COEF 			= 0.4f;
}

class WorldGenerator 
{
	public
	{
		// altitude->color map
		TCOD_color_t mapGradient[256];
		// world height map (0.0 - 1.0)
		TCOD_heightmap_t *hm;
		// height map without erosion
		TCOD_heightmap_t *hm2;
		// complete world map (not shaded)
		TCOD_image_t worldmap;
		// temperature map (in °C)
		TCOD_heightmap_t *temperature;
		// precipitation map (0.0 - 1.0)
		TCOD_heightmap_t *precipitation;
		// biome map
		EBiome[] biomeMap;

		void generate(TCOD_random_t* pwRng)
		{
			float t00, t0 = TCOD_sys_elapsed_seconds();
			t00=t0;
		    cloudDx = cloudTotalDx = 0.0f;
			TCOD_color_gen_map(mapGradient.ptr, MAX_COLOR_KEY, keyColor.ptr, keyIndex.ptr);
			
			TCOD_random_t wRng;
			if ( pwRng is null ) 
			{
				wRng = TCOD_random_get_instance();
			} else
			{
				wRng = *pwRng;
			}
			wgRng = wRng;

			noise = TCOD_noise_new(2, 0.5f, 2.0f, wgRng);
			hm  = TCOD_heightmap_new(HM_WIDTH,HM_HEIGHT);
			hm2 = TCOD_heightmap_new(HM_WIDTH,HM_HEIGHT);
			worldmap = TCOD_image_new(HM_WIDTH,HM_HEIGHT);
			worldint = new float[HM_WIDTH*HM_HEIGHT];
			temperature =   TCOD_heightmap_new(HM_WIDTH,HM_HEIGHT);
			precipitation = TCOD_heightmap_new(HM_WIDTH,HM_HEIGHT);
			biomeMap = new EBiome[HM_WIDTH*HM_HEIGHT];
			mapData = new map_data_t[HM_WIDTH*HM_HEIGHT];
			//memset(mapData,0,sizeof(map_data_t)*HM_WIDTH*HM_HEIGHT);
			
			float t1 = TCOD_sys_elapsed_seconds();
			genLog("Initialization... ", t1-t0 );
			t0=t1;

			buildBaseMap();
			t1 = TCOD_sys_elapsed_seconds();
			genLog("Heightmap construction... ", t1-t0 );
			t0=t1;

			computePrecipitations();
			t1 = TCOD_sys_elapsed_seconds();
			genLog("Precipitation map... ", t1-t0 );
			t0=t1;

			erodeMap();
			t1 = TCOD_sys_elapsed_seconds();
			genLog("Erosion... ", t1-t0 );
			t0=t1;

			smoothMap();
			t1 = TCOD_sys_elapsed_seconds();
			genLog("Smooth... ", t1-t0 );
			t0=t1;

		    setLandMass(0.6f,sandHeight);

			for (int i=0; i < HM_WIDTH*HM_HEIGHT/3000; i++) 
			{
				generateRivers();
			}
			t1 = TCOD_sys_elapsed_seconds();
			genLog("Rivers... ", t1-t0 );
			t0=t1;

		    smoothPrecipitations();
			t1 = TCOD_sys_elapsed_seconds();
			genLog("Smooth precipitations... ", t1-t0 );
			t0=t1;

			computeTemperaturesAndBiomes();
			t1 = TCOD_sys_elapsed_seconds();
			genLog("Temperature map... ", t1-t0 );
			t0=t1;

			computeColors();
			t1 = TCOD_sys_elapsed_seconds();
			genLog("Color map... ", t1-t0 );
			t0=t1;

			t1 = TCOD_sys_elapsed_seconds();
			genLog("TOTAL TIME... ", t1-t00 );			
		}

		int width() @property const
		{
			return HM_WIDTH;
		}

		int height() @property const
		{
			return HM_HEIGHT;
		}

		float getAltitude(int x, int y) const
		{
			return hm.TCOD_heightmap_get_value(x,y);
		}

		float getInterpolatedAltitude(float x, float y) const
		{
			return hm.TCOD_heightmap_get_interpolated_value(x, y);
		}

		float getSandHeight() const
		{
			return sandHeight;
		}

		bool isOnSea(float x, float y) const
		{
			return getInterpolatedAltitude(x, y) <= sandHeight;
		}

		float getCloudThickness(float x, float y) const
		{
		    x += cloudDx;
		    int ix = cast(int)x;
		    int iy = cast(int)y;
		    int ix1 = cast(int)fmin(HM_WIDTH-1,ix+1);
		    int iy1 = cast(int)fmin(HM_HEIGHT-1,iy+1);
		    float fdx = x - ix;
		    float fdy = y - iy;
		    float v1 = clouds[ix][iy];
		    float v2 = clouds[ix1][iy];
		    float v3 = clouds[ix][iy1];
		    float v4 = clouds[ix1][iy1];
		    float vx1 = ((1.0f - fdx) * v1 + fdx * v2);
		    float vx2 = ((1.0f - fdx) * v3 + fdx * v4);
		    float v = ((1.0f - fdy) * vx1 + fdy * vx2);
		    return v;			
		}

		void getInterpolatedNormal(float x, float y, float n[3]) const
		{
			hm2.TCOD_heightmap_get_normal(x, y, n.ptr, sandHeight);
		}

		TCOD_color_t getInterpolatedColor(float worldX, float worldY)
		{
			return getInterpolatedColor(worldmap, worldX, worldY);
		}

		float getInterpolatedIntensity(float worldX, float worldY)
		{
			return getInterpolatedFloat(worldint, worldX, worldY, HM_WIDTH, HM_HEIGHT);
		}

		// update
		void updateClouds(float elapsedTime)
		{
		    cloudTotalDx += elapsedTime * 5;
		    cloudDx += elapsedTime * 5;
		    if ( cloudDx >= 1.0f ) 
		    {
		        int colsToTranslate = cast(int)cloudDx;
		        cloudDx -= colsToTranslate;
		        // translate the cloud map
		        for ( int x=colsToTranslate; x < HM_WIDTH; x++) 
		        {
		            for (int y=0; y < HM_HEIGHT; y++) {
		                clouds[x-colsToTranslate][y]=clouds[x][y];
		            }
		        }
		        // compute a new column
		        float f[2];
		        float cdx = cast(int)cloudTotalDx ;
		        for ( int x = HM_WIDTH-colsToTranslate; x < HM_WIDTH; x++) {
		            for (int y = 0; y < HM_HEIGHT; y++) {
		                f[0] = 6.0f*(cast(float)(x+cdx) / HM_WIDTH);
		                f[1] = 6.0f*(cast(float)(y) / HM_HEIGHT);
		                clouds[x][y] = 0.5f * (1.0f + 0.8f * noise.TCOD_noise_get_fbm(f,4.0f));
		            }
		        }
		    }
		}

		void computeSunLight(float lightDir[3])
		{
			for (int x=0; x < HM_WIDTH; x++) 
			{
				for (int y=0; y < HM_HEIGHT; y++) 
				{
					worldint[x+y*HM_WIDTH]=getMapIntensity(x+0.5f,y+0.5f,lightDir);
				}
			}			
		}
		
		// data
		float getRealAltitude(float x, float y) const // in meters
		{
			int ih = cast(int)(256*getInterpolatedAltitude(x,y));
			ih = clamp(0,255,ih);
			foreach(size_t idx; 0..MAX_ALT_KEY-1)
			{
				if(altIndexes[idx+1] > ih) break;
			}

			size_t idx = MAX_ALT_KEY-2;
			float alt = altitudes[idx] + (altitudes[idx+1]-altitudes[idx]) 
				* (ih - altIndexes[idx]) / (altIndexes[idx+1]-altIndexes[idx]);
			return alt;
		}

		float getPrecipitations(float x, float y) const // in centimeter/m²/year
		{
			int iprec = cast(int)(256*precipitation.TCOD_heightmap_get_value(cast(int)x,cast(int)y));
			iprec=clamp(0,255,iprec);
			foreach(size_t idx; 0..MAX_PREC_KEY-1)
			{
				if ( precIndexes[idx+1] > iprec ) break;
			}

			size_t idx = MAX_PREC_KEY-2;
			float prec = precipitations[idx] + (precipitations[idx+1]-precipitations[idx]) * (iprec-precIndexes[idx])/(precIndexes[idx+1]-precIndexes[idx]);
			return prec;			
		}

		float getTemperature(float x, float y) const // in °C
		{
			return temperature.TCOD_heightmap_get_value(cast(int)x,cast(int)y);
		}

		EBiome getBiome(float x, float y) const
		{
			return biomeMap[cast(int)x+cast(int)y*HM_WIDTH];
		}

		// map generators
		void saveBiomeMap(string filename = "")
		{
		    static TCOD_image_t legend;
		    static int legendHeight, legendWidth;
		    static const TCOD_color_t biomeColors[] = [
			    // TUNDRA,
			    TCOD_color_t(88,234,250),
			    // COLD_DESERT,
			    TCOD_color_t(129,174,170),
			    // GRASSLAND,
			    TCOD_color_t(0, 255, 127),
			    // BOREAL_FOREST,
			    TCOD_color_t(14,93,43),
			    // TEMPERATE_FOREST,
			    TCOD_color_t(44,177,83),
			    // TROPICAL_MONTANE_FOREST,
			    TCOD_color_t(185,232,164),
			    // HOT_DESERT,
			    TCOD_color_t(229,247,184),
			    // SAVANNA,
			    TCOD_color_t(255, 127, 0),
			    // TROPICAL_DRY_FOREST,
			    TCOD_color_t(255, 255, 0),
			    // TROPICAL_EVERGREEN_FOREST,
			    TCOD_color_t(0, 255, 0),
			    // THORN_FOREST,
			    TCOD_color_t(192,192,112),
		    ];

		    legend = TCOD_image_load("data/img/legend_biome.png");
		    legend.TCOD_image_get_size(&legendWidth,&legendHeight);

		    if ( filename == "" ) filename="world_biome.png";

		    TCOD_image_t img = TCOD_image_new(cast(int)fmax(HM_WIDTH,legendWidth),HM_HEIGHT+legendHeight);
		    // draw biome map
			for (size_t x=0; x < HM_WIDTH; x++) 
			{
				for (size_t y=0; y < HM_HEIGHT; y++) 
				{
				    float h = hm.TCOD_heightmap_get_value(x,y);
				    if ( h < sandHeight ) TCOD_image_put_pixel(img, x,y,TCOD_color_t(100,100,255));
				    else TCOD_image_put_pixel(img, x, y, biomeColors[biomeMap[x+y*HM_WIDTH]]);
				}
			}
			drawCoasts(img);

			// blit legend
			int legendx = cast(int)fmax(HM_WIDTH,legendWidth) / 2 - legendWidth/2;
			for (size_t x=0; x < legendWidth; x++) 
			{
				for (size_t y=0; y < legendHeight; y++) 
				{
				    TCOD_image_put_pixel(img, legendx+x, HM_HEIGHT+y, legend.TCOD_image_get_pixel(x,y));
				}
			}

			// fill legend colors
			for (size_t i=0; i < 6; i++ ) 
			{
		        for (int x=17; x < 47; x++)
		            for (int y=4+i*14; y < 14+i*14; y++ )
		                TCOD_image_put_pixel(img, legendx+x,HM_HEIGHT+y,biomeColors[i]);
			}
			for (size_t i=6; i < EBiome.NB_BIOMES; i++ ) 
			{
		        for (int x=221; x < 251; x++)
		            for (int y=4+(i-6)*14; y < 14+(i-6)*14; y++ )
		                TCOD_image_put_pixel(img, legendx+x,HM_HEIGHT+y,biomeColors[i]);
			}
			img.TCOD_image_save(toStringz(filename));
		}

		void saveAltitudeMap(string filename = "")
		{
		    static TCOD_color_t altGradient[256];

		    static TCOD_image_t legend;
		    static int legendHeight,legendWidth;

		    legend = TCOD_image_load("data/img/legend_altitude.png");
		    legend.TCOD_image_get_size(&legendWidth,&legendHeight);
		    TCOD_color_gen_map(altGradient.ptr, MAX_ALT_KEY, altColors.ptr, altIndexes.ptr);

		    if ( filename == "" ) filename="world_altitude.png";

		    TCOD_image_t img = TCOD_image_new(HM_WIDTH+legendWidth,cast(int)fmax(HM_HEIGHT,legendHeight));
		    
		    // render altitude map
		    for (int x=0; x < HM_WIDTH; x++) 
		    {
		        for (int y=0; y < HM_HEIGHT; y++) 
		        {
		            float h = hm.TCOD_heightmap_get_value(x,y);
		            size_t ialt = cast(size_t)(h * 256);
		            ialt = clamp(0,255,cast(int)ialt);
		            TCOD_image_put_pixel(img, x,y,altGradient[ialt]);
		        }
		    }

			// blit legend
			int legendy = cast(int)fmax(HM_HEIGHT,legendHeight) / 2 - legendHeight/2;
			for (int x=0; x < legendWidth; x++) 
			{
				for (int y=0; y < legendHeight; y++) 
				{
				    TCOD_image_put_pixel(img, HM_WIDTH+x,legendy+y,legend.TCOD_image_get_pixel(x,y));
				}
			}
		    img.TCOD_image_save(toStringz(filename));
		}

		void saveTemperatureMap(string filename = "")
		{
		    static TCOD_color_t tempGradient[256];

		    static TCOD_image_t legend;
		    static int legendHeight,legendWidth;
		    
	        legend = TCOD_image_load("data/img/legend_temperature.png");
	        legend.TCOD_image_get_size(&legendWidth,&legendHeight);
	        TCOD_color_gen_map(tempGradient.ptr, MAX_TEMP_KEY, tempKeyColor.ptr, tempIndexes.ptr);
		    

		    if ( filename == "" ) filename="world_temperature.png";

		    TCOD_image_t img = TCOD_image_new(cast(int)fmax(HM_WIDTH,legendWidth), HM_HEIGHT+legendHeight);

		    float minTemp,maxTemp;
		    temperature.TCOD_heightmap_get_minmax(&minTemp,&maxTemp);

		    // render temperature map
		    for (int x=0; x < HM_WIDTH; x++) 
		    {
		        for (int y=0; y < HM_HEIGHT; y++) 
		        {
				    float h = hm.TCOD_heightmap_get_value(x,y);
				    if ( h < sandHeight ) TCOD_image_put_pixel(img, x, y, TCOD_color_t(100,100,255));
				    else 
				    {
			            float temp = temperature.TCOD_heightmap_get_value(x,y);
			            temp = (temp - minTemp) / (maxTemp-minTemp);
			            int colorIdx = cast(int)(temp*255);
			            colorIdx = clamp(0,255,colorIdx);
			            TCOD_image_put_pixel(img, x,y,tempGradient[colorIdx]);
			        }
		        }
		    }
		    drawCoasts(img);

			// blit legend
			int legendx = cast(int)fmax(HM_WIDTH, legendWidth) / 2 - legendWidth/2;
			for (int x=0; x < legendWidth; x++) {
				for (int y=0; y < legendHeight; y++) {
				    TCOD_image_put_pixel(img, legendx+x,HM_HEIGHT+y,legend.TCOD_image_get_pixel(x,y));
				}
			}
		    img.TCOD_image_save(toStringz(filename));
		}

		void savePrecipitationMap(string filename = "")
		{
		    static TCOD_image_t legend;
		    static int legendHeight,legendWidth;

	        legend = TCOD_image_load("data/img/legend_precipitation.png");
	        legend.TCOD_image_get_size(&legendWidth,&legendHeight);

		    if ( filename == "" ) filename="world_precipitation.png";

		    TCOD_image_t img = TCOD_image_new(cast(int)fmax(HM_WIDTH,legendWidth),HM_HEIGHT+legendHeight);

		    // render precipitation map
		    for (int x=0; x < HM_WIDTH; x++) 
		    {
		        for (int y=0; y < HM_HEIGHT; y++) 
		        {
				    float h = hm.TCOD_heightmap_get_value(x,y);
				    if ( h < sandHeight ) TCOD_image_put_pixel(img, x, y, TCOD_color_t(100,100,255));
				    else 
				    {
			            float prec = precipitation.TCOD_heightmap_get_value(x,y);
			            int iprec = cast(int)(prec * 180);
			            int colorIdx=0;
			            while (colorIdx < MAX_PREC_KEY && iprec > precIndexes[colorIdx]) colorIdx++;
			            colorIdx = clamp(0,MAX_PREC_KEY,colorIdx);
			            TCOD_image_put_pixel(img, x,y,precColors[colorIdx]);
			        }
		        }
		    }
		    drawCoasts(img);

			// blit legend
			int legendx = cast(int)fmax(HM_WIDTH, legendWidth) / 2 - legendWidth/2;
			for (int x=0; x < legendWidth; x++) 
			{
				for (int y=0; y < legendHeight; y++) 
				{
				    TCOD_image_put_pixel(img, legendx+x, HM_HEIGHT+y, legend.TCOD_image_get_pixel(x,y));
				}
			}
		    img.TCOD_image_save(toStringz(filename));
		}		
	}
	protected
	{
		/*class RiverPathCbk : ITCODPathCallback 
		{
		    float getWalkCost( int xFrom, int yFrom, int xTo, int yTo, void *userData ) const 
		    {
		        WorldGenerator *world = cast(WorldGenerator *)userData;
		        float h1 = world.hm.getValue(xFrom,yFrom);
		        float h2 = world.hm.getValue(xTo,yTo);
		        if ( h2 < sandHeight ) return 0.0f;
				// float f[2] = {xFrom*10.0f/HM_WIDTH,yFrom*10.0f/HM_HEIGHT};
				// return (1.0f+h2-h1)*10+5*(1.0f+noise2d.getSimplex(f));
		        return (0.01f+h2-h1)*100;
		    }
		};*/

		TCOD_noise_t noise;
		// cloud thickness
		float clouds[HM_WIDTH][HM_HEIGHT];
		float cloudDx; // horizontal offset for smooth scrolling
		float cloudTotalDx;
		// world light intensity map (shadow map)
		float[] worldint;

		struct map_data_t
		{
			float slope;
			// number of cells flowing into this cell
			uint area;
			// direction of lowest neighbour
			ubyte flowDir;
			// inverse flow direction
			ubyte upDir;
			ubyte inFlags; // incoming flows
			ubyte riverId;
			int riverLength;
		}
		map_data_t[] mapData;

		struct river_t
		{
		    SList!int coords;
		    Array!int strength;
		}
		SList!river_t rivers;
		TCOD_random_t wgRng;
	}
	protected
	{
		void addHill(int nbHill, float baseRadius, float radiusVar, float height)
		{
			for (int i=0; i< nbHill; i++ ) 
			{
				float hillMinRadius = baseRadius*(1.0f-radiusVar);
				float hillMaxRadius = baseRadius*(1.0f+radiusVar);
				float radius = wgRng.TCOD_random_get_float(hillMinRadius, hillMaxRadius);
				int xh = wgRng.TCOD_random_get_int(0,HM_WIDTH-1);
				int yh = wgRng.TCOD_random_get_int(0,HM_HEIGHT-1);
				hm.TCOD_heightmap_add_hill(cast(float)xh,cast(float)yh,radius,height);
			}
		}

		void buildBaseMap()
		{
			float t0 = TCOD_sys_elapsed_seconds();
			addHill(600,16.0*HM_WIDTH/200,0.7,0.3);
			hm.TCOD_heightmap_normalize(0.0f, 1.0f);
			float t1 = TCOD_sys_elapsed_seconds();

			genLog("  Hills... ", t1-t0 );
			t0=t1;

			hm.TCOD_heightmap_add_fbm(noise,2.20*HM_WIDTH/400,2.20*HM_WIDTH/400,0,0,10.0f,1.0,2.05);
			hm.TCOD_heightmap_normalize(0.0f, 1.0f);
			TCOD_heightmap_copy(hm, hm2);
			t1 = TCOD_sys_elapsed_seconds();

			genLog("  Fbm... ", t1-t0 );
			t0=t1;

		    setLandMass(0.6f,sandHeight);

			// fix land/mountain ratio using x^3 curve above sea level
			for ( int x=0; x < HM_WIDTH; x++) 
			{
			    for (int y=0; y < HM_HEIGHT; y++) 
			    {
					float h = hm.TCOD_heightmap_get_value(x,y);
					if ( h >= sandHeight ) 
					{
		                float coef = (h-sandHeight) / (1.0f - sandHeight);
					    h = sandHeight + coef * coef * coef * (1.0f - sandHeight);
					    hm.TCOD_heightmap_set_value(x,y,h);
					}
			    }
			}

			t1 = TCOD_sys_elapsed_seconds();
			genLog("  Flatten plains... ", t1-t0 );
			t0=t1;

			// we use a custom erosion algo
			//hm.rainErosion(15000*HM_WIDTH/400,0.03,0.01,wgRng);
			//t1=TCODSystem.getElapsedSeconds();
			//DBG(("  Erosion... %g\n", t1-t0 ));
			//t0=t1;

			// compute clouds
			float f[2];
			for ( int x=0; x < HM_WIDTH; x++) 
			{
		        f[0] = 6.0f*(cast(float)(x) / HM_WIDTH);
			    for (int y=0; y < HM_HEIGHT; y++) 
			    {
		            f[1] = 6.0f*(cast(float)(y) / HM_HEIGHT);
		            TCOD_noise_set_type(noise, TCOD_NOISE_SIMPLEX);
		            clouds[x][y] = 0.5f * (1.0f + 0.8f * noise.TCOD_noise_get_fbm(f.ptr, 4.0f));
			    }
			}
			t1 = TCOD_sys_elapsed_seconds();
			genLog("  Init clouds... ", t1-t0 );
			t0 = t1;
		}		

		void erodeMap()
		{
			TCOD_heightmap_t* newMap = TCOD_heightmap_new(HM_WIDTH,HM_HEIGHT);
			for (int i=5; i != 0; i --) 
			{
				// compute flow and slope maps
				map_data_t* md = &mapData[0];
				for (int y=0; y < HM_HEIGHT; y++) 
				{
		            for (int x=0; x < HM_WIDTH; x++) 
		            {
						float h = hm.TCOD_heightmap_get_value(x,y);
						float hmin = h, hmax = h;
						int minDir = 0, maxDir = 0;
						for (int ii=1; ii< 9; ii++ ) 
						{
							int ix = x+dirx[ii];
							int iy = y+diry[ii];
							if ( inRectangle(ix,iy,HM_WIDTH,HM_HEIGHT)) 
							{
								float h2 = hm.TCOD_heightmap_get_value(ix,iy);
								if ( h2 < hmin ) 
								{
									hmin = h2;
									minDir = ii;
								} else if ( h2 > hmax ) 
								{
									hmax = h2;
									maxDir = ii;
								}
							}
						}
						md.flowDir = cast(ubyte)minDir;
						md.upDir = cast(ubyte)maxDir;
						float slope = hmin - h; // this is negative
						slope *= dircoef[minDir];
						md.slope = slope;
						md++;
					}
				}

				md = &mapData[0];
				for (int y=0; y < HM_HEIGHT; y++) 
				{
		            for (int x=0; x < HM_WIDTH; x++) 
		            {
		                float sediment = 0.0f;
		                bool end = false;
		                int ix = x, iy = y;
		                ubyte oldFlow = md.flowDir;
		                map_data_t *md2 = md;
		                while ( !end ) 
		                {
		                    float h = hm.TCOD_heightmap_get_value(ix,iy);
		                    if (h < sandHeight-0.01f) break;
		                    if ( md2.flowDir == oppdir[oldFlow] ) 
		                    {
		                        h += SEDIMENTATION_FACTOR * sediment;
		                        hm.TCOD_heightmap_set_value(ix,iy,h);
		                        end = true;
		                    } else 
		                    {
		                        // remember, slope is negative
		                        h += precipitation.TCOD_heightmap_get_value(ix,iy)* EROSION_FACTOR * md2.slope;
		                        h = cast(float)fmax(h,sandHeight);
		                        sediment -= md2.slope;
		                        hm.TCOD_heightmap_set_value(ix,iy,h);
		                        oldFlow = md2.flowDir;
		                        ix += dirx[oldFlow];
		                        iy += diry[oldFlow];
		                        md2 = &mapData[ix+iy*HM_WIDTH];
		                    }
		                }
		                md++;
					}
		        }
				genLog("  Erosion pass ",i);

				// mudslides (smoothing)
				float sandCoef = 1.0f/(1.0f-sandHeight);
				for (int x=0; x < HM_WIDTH; x++) 
				{
					for (int y=0; y < HM_HEIGHT; y++) 
					{
						float h = hm.TCOD_heightmap_get_value(x,y);
						if ( h < sandHeight-0.01f || h >= MAX_EROSION_ALT ) 
						{
							newMap.TCOD_heightmap_set_value(x,y,h);
							continue;
						}
						float sumDelta1 = 0.0f, sumDelta2 = 0.0f;
						int nb1 = 1, nb2 = 1;
						for (int ii=1; ii < 9; ii++ ) 
						{
							int ix = x+dirx[ii];
							int iy = y+diry[ii];
							if ( inRectangle(ix, iy, HM_WIDTH,HM_HEIGHT)) 
							{
								float ih = hm.TCOD_heightmap_get_value(ix,iy);
								if ( ih < h ) {
									if ( ii ==1 || ii == 3 || ii == 6 || ii == 8 ) {
										// diagonal neighbour
										sumDelta1 += (ih - h)*0.4f;
										nb1++;
									} else {
										// adjacent neighbour
										sumDelta2 += (ih -h)*1.6f;
										nb2++;
									}
								}
							}
						}
						// average height difference with lower neighbours
						float dh = sumDelta1/nb1 + sumDelta2/nb2;
						dh *= MUDSLIDE_COEF;
						float hcoef=(h-sandHeight)* sandCoef;
						dh *= (1.0f-hcoef*hcoef*hcoef); // less smoothing at high altitudes

						newMap.TCOD_heightmap_set_value(x,y,h+dh);
					}
				}
				TCOD_heightmap_copy(newMap, hm);
			}
		}	

		void smoothMap()
		{
			// 3x3 kernel for smoothing operations
			static const int smoothKernelSize = 9;
			static const int smoothKernelDx[9] = [-1,0,1,-1,0,1,-1,0,1];
			static const int smoothKernelDy[9] = [-1,-1,-1,0,0,0,1,1,1];
			static const float smoothKernelWeight[9] = [2,8,2,8,20,8,2,8,2];

			debug
			{
				float t0 = TCOD_sys_elapsed_seconds();
			}

			hm.TCOD_heightmap_kernel_transform(smoothKernelSize, smoothKernelDx.ptr, smoothKernelDy.ptr, smoothKernelWeight,-1000,1000);
			hm2.TCOD_heightmap_kernel_transform(smoothKernelSize, smoothKernelDx.ptr, smoothKernelDy.ptr, smoothKernelWeight,-1000,1000);
			hm.TCOD_heightmap_normalize(0.0f, 1.0f);

			debug
			{
				float t1 = TCOD_sys_elapsed_seconds();
				genLog("  Blur... ", t1-t0 );
			}
		}

		// compute the ground color from the heightmap
		TCOD_color_t getMapColor(float h)
		{
			int colorIdx;
			if ( h < sandHeight ) colorIdx = cast(int)(h/sandHeight * COLOR_KEY_MAX_SEA);
			else colorIdx = COLOR_KEY_MIN_LAND + cast(int)((h-sandHeight)/(1.0f-sandHeight) * (255-COLOR_KEY_MIN_LAND));
			colorIdx=clamp(0,255,colorIdx);
			return mapGradient[colorIdx];			
		}

		// get sun light intensity on a point of the map
		float getMapIntensity(float worldX,float worldY, float lightDir[3])
		{
		    // sun color & direction
		    static const TCOD_color_t sunCol = TCOD_color_t(255,255,160);
			float normal[3];
		    float wx = clamp(0.0f, cast(float)HM_WIDTH-1, worldX);
		    float wy = clamp(0.0f, cast(float)HM_HEIGHT-1, worldY);

			// apply sun light
		    getInterpolatedNormal(wx,wy,normal);
			normal[2] *= 3.0f;
		    float intensity = 0.75f
				- (normal[0]*lightDir[0]+normal[1]*lightDir[1]+normal[2]*lightDir[2])*0.75f;
			intensity=clamp(0.75f,1.5f,intensity);
			return intensity;			
		}
		
		TCOD_color_t getInterpolatedColor(TCOD_image_t img, float x, float y) 
		{
			int w,h;
			img.TCOD_image_get_size(&w,&h);
			float wx = clamp(0.0f, cast(float)w-1,x);
			float wy = clamp(0.0f, cast(float)h-1,y);
			int iwx = cast(int)wx;
			int iwy = cast(int)wy;
			float dx = wx - iwx;
			float dy = wy - iwy;

			TCOD_color_t colNW = img.TCOD_image_get_pixel(iwx,iwy);
			TCOD_color_t colNE = (iwx < w-1 ? img.TCOD_image_get_pixel(iwx+1,iwy) : colNW);
			TCOD_color_t colSW = (iwy < h-1 ? img.TCOD_image_get_pixel(iwx,iwy+1) : colNW);
			TCOD_color_t colSE = (iwx < w-1 && iwy < h-1 ? img.TCOD_image_get_pixel(iwx+1,iwy+1) : colNW);
			TCOD_color_t colN = TCOD_color_lerp(colNW,colNE,dx);
			TCOD_color_t colS = TCOD_color_lerp(colSW,colSE,dx);
			TCOD_color_t col = TCOD_color_lerp(colN,colS,dy);
			return col;
		}

		float getInterpolatedFloat(float[] arr, float x, float y, int width, int height)
		{
			float wx = clamp(0.0f, cast(float)width-1,x);
			float wy = clamp(0.0f, cast(float)height-1,y);
			int iwx = cast(int)wx;
			int iwy = cast(int)wy;
			float dx = wx - iwx;
			float dy = wy - iwy;

			float iNW = arr[iwx+iwy*width];
			float iNE = (iwx < width-1 ? arr[iwx+1+iwy*width] : iNW);
			float iSW = (iwy < height-1 ? arr[iwx+(iwy+1)*width] : iNW);
			float iSE = (iwx < width-1 && iwy < height-1 ? arr[iwx+1+(iwy+1)*width] : iNW);
			float iN = (1.0f-dx)*iNW + dx*iNE;
			float iS = (1.0f-dx)*iSW + dx*iSE;
			return (1.0f-dy)*iN + dy * iS;			
		}

		void generateRivers()
		{
		    static int riverId = 0;
			// the source
			int sx,sy;
			// the destination
			int dx,dy;

			// get a random point near the coast
			sx = wgRng.TCOD_random_get_int(0,HM_WIDTH-1);
			sy = wgRng.TCOD_random_get_int(HM_HEIGHT/5,4*HM_HEIGHT/5);
			float h = hm.TCOD_heightmap_get_value(sx,sy);
			while ( h <  sandHeight - 0.02 || h >= sandHeight ) 
			{
				sx++;
				if ( sx == HM_WIDTH ) 
				{
					sx=0;
					sy++;
					if ( sy == HM_HEIGHT ) sy=0;
				}
				h = hm.TCOD_heightmap_get_value(sx,sy);
			}
			SList!int tree;
			SList!int randPt;
			tree.insert(sx+sy*HM_WIDTH);
			riverId++;
			dx = sx;
			dy = sy;
			for (int i=0; i< wgRng.TCOD_random_get_int(50,200); i++) 
			{
			    int rx = wgRng.TCOD_random_get_int(sx-200,sx+200);
			    int ry = wgRng.TCOD_random_get_int(sy-200,sy+200);
		//	    if ( inRectangle(rx,ry,HM_WIDTH,HM_HEIGHT) ) {
		//	        float h=hm.TCOD_heightmap_get_value(rx,ry);
		//	        if ( h >= sandHeight ) {
			            randPt.insert(rx+ry*HM_WIDTH);
		//	        }
		//	    }
			}

		    //for (int i=0; i < randPt.length; i++) 
		    foreach(randPtEl; randPt)
		    {
		        int rx = randPtEl%HM_WIDTH;
		        int ry = randPtEl/HM_WIDTH;

		        float minDist = 1E10;
		        int bestx = -1,besty = -1;
		        //for (int j=0;j < tree.length; j++) 
		        foreach(treeEl; tree)
		        {
		            int tx = treeEl%HM_WIDTH;
		            int ty = treeEl/HM_WIDTH;
		            float dist = (tx-rx)*(tx-rx)+(ty-ry)*(ty-ry);
		            if ( dist < minDist) 
		            {
		                minDist=dist;
		                bestx=tx;
		                besty=ty;
		            }
		        }
		        TCOD_line_init(bestx, besty, rx, ry);

		        int len = 3, cx = bestx, cy = besty;
		        map_data_t *md = &mapData[cx+cy*HM_WIDTH];

		        if (md.riverId == riverId ) md.riverId=0;
		        do 
		        {
		            md =& mapData[cx+cy*HM_WIDTH];
		            if (md.riverId > 0 ) return;
			        float h2 = hm.TCOD_heightmap_get_value(cx,cy);
			        if ( h2 >= sandHeight ) 
			        {
		                md.riverId = cast(ubyte)riverId;
		                precipitation.TCOD_heightmap_set_value(cx,cy,1.0f);
			        }
			        if (cx ==0 || cx == HM_WIDTH-1 || cy == 0 || cy == HM_HEIGHT-1 ) len = 0;
		            else if (TCOD_line_step(&cx,&cy)) len=0;
		            len --;
		        } while(len > 0 );
		        int newNode = cx+cy*HM_WIDTH;
		        if (newNode != bestx+besty*HM_WIDTH ) 
		        {
		            tree.insert(newNode);
		        }
		    }			
		}

		void smoothPrecipitations()
		{
			float t0 = TCOD_sys_elapsed_seconds();

			// better quality polishing blur using a 5x5 kernel
			// faster than TCODHeightmap kernelTransform function
			TCOD_heightmap_t *temphm = TCOD_heightmap_new(HM_WIDTH, HM_HEIGHT);
			TCOD_heightmap_copy(precipitation, temphm);
			for (int i=4; i != 0; i--) 
			{
				for (int x=0; x < HM_WIDTH; x++) 
				{
					int minx = x - 2;
					int maxx = x + 2;
					int miny=0;
					int maxy=2;
					float sum=0.0f;
					int count=0;
					minx = cast(int)fmax( 0, minx );
					maxx = cast(int)fmin( HM_WIDTH-1, maxx);
					// compute the kernel sum at x,0
					for (int ix=minx; ix <= maxx; ix++) 
					{
						for (int iy =miny; iy <= maxy; iy++) 
						{
							sum += precipitation.TCOD_heightmap_get_value(ix,iy);
							count++;
						}
					}
					temphm.TCOD_heightmap_set_value(x,0,sum/count);

					for (int y=1; y < HM_HEIGHT; y++) 
					{
						if ( y-2 >= 0 ) 
						{
							// remove the top-line sum
							for (int ix=minx; ix <= maxx; ix++) 
							{
								sum -= precipitation.TCOD_heightmap_get_value(ix,y-2);
								count--;
							}
						}
						if ( y+2 < HM_HEIGHT ) 
						{
							// add the bottom-line sum
							for (int ix=minx; ix <= maxx; ix++) 
							{
								sum += precipitation.TCOD_heightmap_get_value(ix,y+2);
								count++;
							}
						}
						temphm.TCOD_heightmap_set_value(x,y,sum/count);
					}
				}
			}
			TCOD_heightmap_copy(temphm, precipitation);

			float t1 = TCOD_sys_elapsed_seconds();
			genLog("  Blur... ", t1-t0 );
			t0=t1;

			precipitation.TCOD_heightmap_normalize(0.0f, 1.0f);
			t1 = TCOD_sys_elapsed_seconds();
			genLog("  Normalization... ", t1-t0 );
			t0=t1;			
		}

		int getRiverStrength(int riverId)
		{
		    //river_t *river = rivers.get(riverId-1);
		    //return river.strength.get(river.strength.size()-1);
		    return 2;
		}

		void setLandMass(float landMass, float waterLevel)
		{
			// fix land mass. We want a proportion of landMass above sea level
			debug 
			{
				float t0 = TCOD_sys_elapsed_seconds();
			}

			int heightcount[256];
			for (int x=0; x < HM_WIDTH; x++) 
			{
			    for (int y=0; y < HM_HEIGHT; y++) 
			    {
					float h = hm.TCOD_heightmap_get_value(x,y);
					int ih = cast(int)(h*255);
					ih = clamp(0,255,ih);
					heightcount[cast(size_t)ih]++;
				}
			}
			int i=0, totalcount=0;
			while (totalcount < HM_WIDTH*HM_HEIGHT*(1.0f-landMass) ) 
			{
				totalcount += heightcount[cast(size_t)i];
				i++;
			}
			float newWaterLevel=i/255.0f;
			float landCoef = (1.0f-waterLevel)/(1.0f-newWaterLevel);
			float waterCoef = waterLevel / newWaterLevel;
			// water level should be rised/lowered to newWaterLevel
			for ( int x=0; x < HM_WIDTH; x++) 
			{
			    for (int y=0; y < HM_HEIGHT; y++) 
			    {
					float h = hm.TCOD_heightmap_get_value(x,y);
					if ( h > newWaterLevel ) 
					{
						h = waterLevel + (h-newWaterLevel)*landCoef;
					} else 
					{
						h = h * waterCoef;
					}
					hm.TCOD_heightmap_set_value(x,y,h);
				}
			}
			debug
			{
				float t1 = TCOD_sys_elapsed_seconds();
				genLog("  Landmass... ", t1-t0 );
			}
		}

		void computeTemperaturesAndBiomes()
		{
			// temperature shift with altitude : -25°C at 6000 m
			// mean temp at sea level : 25°C at lat 0  5°C at lat 45 -25°C at lat 90 (sinusoide)
			float sandCoef = 1.0f/(1.0f-sandHeight);
			float waterCoef = 1.0f/sandHeight;
			for (int y=0; y < HM_HEIGHT; y++) 
			{
				float lat = cast(float)(y-HM_HEIGHT/2) * 2 / HM_HEIGHT ;
				float latTemp = 0.5f*(1.0f+pow(sin(3.1415926*(lat+0.5f)),5)); // between 0 and 1
				if ( latTemp > 0.0f) latTemp = cast(float)sqrt(latTemp);
				latTemp = -30 + latTemp*60;
				for (int x=0; x < HM_WIDTH; x++) 
				{
					float h0 = hm.TCOD_heightmap_get_value(x,y);
					float h = h0 - sandHeight;
					if (h < 0.0f ) h *= waterCoef;
					else h *= sandCoef;
					float altShift = -35 * h;
					float temp = latTemp+altShift;
					temperature.TCOD_heightmap_set_value(x,y,temp);
					float humid = precipitation.TCOD_heightmap_get_value(x,y);
					// compute biome
					EClimate climate = getClimateFromTemp(temp);
					int iHumid = cast(int)(humid * 5);
					iHumid = cast(int)fmin(4,iHumid);
					EBiome biome = biomeDiagram[climate][iHumid];
					biomeMap[x+y*HM_WIDTH]=biome;
				}
			}
			float min,max;
			temperature.TCOD_heightmap_get_minmax(&min,&max);
			genLog("Temperatures min/max: ", min, " / ", max);
		}

		TCOD_color_t getBiomeColor(EBiome biome, int x, int y)
		{
		    static const TCOD_color_t biomeColors[] = 
		    [
			    // TUNDRA,
			    TCOD_color_t(200,240,255),
			    // COLD_DESERT,
			    TCOD_color_t(180,210,210),
			    // GRASSLAND,
			    TCOD_color_t(0, 255, 127),
			    // BOREAL_FOREST,
			    TCOD_color_t(14,93,43),
			    // TEMPERATE_FOREST,
			    TCOD_color_t(44,177,83),
			    // TROPICAL_MONTANE_FOREST,
			    TCOD_color_t(185,232,164),
			    // HOT_DESERT,
			    TCOD_color_t(235,255,210),
			    // SAVANNA,
			    TCOD_color_t(255,205,20),
			    // TROPICAL_DRY_FOREST,
			    TCOD_color_t(60,130,40),
			    // TROPICAL_EVERGREEN_FOREST,
			    TCOD_color_t(0, 255, 0),
			    // THORN_FOREST,
			    TCOD_color_t(192,192,112),
		    ];
		    int r = 0, g = 0, b = 0, count = 1;
		    r += biomeColors[biome].r;
		    g += biomeColors[biome].g;
		    b += biomeColors[biome].b;
		    for (int i = 0; i < 4; i++ ) 
		    {
		        int ix = x+wgRng.TCOD_random_get_int(-10,10);
		        int iy = y+wgRng.TCOD_random_get_int(-10,10);
		        if ( inRectangle(ix, iy, HM_WIDTH, HM_HEIGHT) ) 
		        {
		            TCOD_color_t c = biomeColors[biomeMap[ix+iy*HM_WIDTH]];
		            r += c.r + wgRng.TCOD_random_get_int(-10,10);
		            g += c.g + wgRng.TCOD_random_get_int(-10,10);
		            b += c.b + wgRng.TCOD_random_get_int(-10,10);
		            count++;
		        }
		    }
		    r /= count;
		    g /= count;
		    b /= count;
		    r = clamp(0,255,r);
		    g = clamp(0,255,g);
		    b = clamp(0,255,b);
		    return TCOD_color_t(cast(ubyte)r, cast(ubyte)g, cast(ubyte)b);			
		}

		void computePrecipitations()
		{
			TCOD_noise_t noise1d = TCOD_noise_new(1, 0.5f, 2.0f, wgRng);
			TCOD_noise_t noise2d = TCOD_noise_new(2, 0.5f, 2.0f, wgRng);

		    static const float waterAdd = 0.03f;
		    static const float slopeCoef = 2.0f;
		    static const float basePrecip = 0.01f; // precipitation coef when slope == 0
			float t0 = TCOD_sys_elapsed_seconds();
		    // north/south winds
		    for (int diry=-1; diry <= 1; diry += 2 ) 
		    {
		        for (int x=0; x < HM_WIDTH; x++) 
		        {
		            float noisex = cast(float)(x)*5/HM_WIDTH;
		            noise1d.TCOD_noise_set_type(TCOD_NOISE_SIMPLEX);
		            float waterAmount = (1.0f+noise1d.TCOD_noise_get_fbm(&noisex,3.0f));
		            int starty = (diry == -1 ? HM_HEIGHT-1 : 0);
		            int endy = (diry == -1 ? -1 : HM_HEIGHT);
		            for (int y=starty; y != endy; y += diry) 
		            {
		                float h = hm.TCOD_heightmap_get_value(x,y);
		                if ( h < sandHeight ) 
		                {
		                    waterAmount += waterAdd;
		                } else if (waterAmount > 0.0f )
		                {
		                    float slope;
		                    if ( cast(uint)(y + diry) < cast(uint)HM_HEIGHT ) slope = hm.TCOD_heightmap_get_value(x,y+diry) - h;
		                    else slope = h - hm.TCOD_heightmap_get_value(x,y-diry);
		                    if ( slope >= 0.0f ) 
		                    {
		                        float precip = waterAmount * (basePrecip + slope * slopeCoef);
		                        precipitation.TCOD_heightmap_set_value(x,y,precipitation.TCOD_heightmap_get_value(x,y)+precip);
		                        waterAmount -= precip;
		                        waterAmount = cast(float)fmax(0.0f,waterAmount);
		                    }
		                }
		            }
		        }
		    }
			float t1 = TCOD_sys_elapsed_seconds();
			genLog("  North/south winds... ", t1-t0 );
			t0=t1;

		    // east/west winds
		    for (int dirx=-1; dirx <= 1; dirx += 2 ) 
		    {
		        for (int y=0; y < HM_HEIGHT; y++) 
		        {
		            float noisey = cast(float)(y)*5/HM_HEIGHT;
		            noise1d.TCOD_noise_set_type(TCOD_NOISE_SIMPLEX);
		            float waterAmount=(1.0f+noise1d.TCOD_noise_get_fbm(&noisey,3.0f));
		            int startx = (dirx == -1 ? HM_WIDTH-1 : 0);
		            int endx = (dirx == -1 ? -1 : HM_WIDTH);
		            for (int x=startx; x != endx; x += dirx) 
		            {
		                float h = hm.TCOD_heightmap_get_value(x,y);
		                if ( h < sandHeight ) 
		                {
		                    waterAmount += waterAdd;
		                } else if (waterAmount > 0.0f )
		                {
		                    float slope;
		                    if ( cast(uint)(x + dirx) < cast(uint)HM_WIDTH ) slope = hm.TCOD_heightmap_get_value(x+dirx,y) - h;
		                    else slope = h - hm.TCOD_heightmap_get_value(x-dirx,y);
		                    if ( slope >= 0.0f ) 
		                    {
		                        float precip = waterAmount * (basePrecip + slope * slopeCoef);
		                        precipitation.TCOD_heightmap_set_value(x,y,precipitation.TCOD_heightmap_get_value(x,y)+precip);
		                        waterAmount -= precip;
		                        waterAmount = cast(float)fmax(0.0f,waterAmount);
		                    }
		                }
		            }
		        }
		    }
			t1 = TCOD_sys_elapsed_seconds();
			genLog("  East/west winds... ", t1-t0 );
			t0=t1;

			float min,max;
			precipitation.TCOD_heightmap_get_minmax(&min,&max);

		    // latitude impact
			for (int y = HM_HEIGHT/4; y < 3*HM_HEIGHT/4; y++) 
			{
		        // latitude (0 : equator, -1/1 : pole)
		        float lat = cast(float)(y-HM_HEIGHT/4) * 2 / HM_HEIGHT ;
		        float coef = cast(float)sin(2*3.1415926*lat );
		        for (int x=0; x < HM_WIDTH; x++) 
		        {
		            float f[2] = [ cast(float)(x)/HM_WIDTH, cast(float)(y)/HM_HEIGHT ];
		            noise2d.TCOD_noise_set_type(TCOD_NOISE_SIMPLEX);
		            float xcoef = coef + 0.5f*noise2d.TCOD_noise_get_fbm(f,3.0f);
		            float precip = precipitation.TCOD_heightmap_get_value(x,y);
		            precip +=  (max-min) * xcoef * 0.1f;
		            precipitation.TCOD_heightmap_set_value(x,y,precip);
				}
			}
			t1 = TCOD_sys_elapsed_seconds();
			genLog("  latitude... ", t1-t0 );
			t0 = t1;

			import std.c.string;
			// very fast blur by scaling down and up
			static const int factor=8;
			static const int smallWidth = (HM_WIDTH+factor-1)/factor;
			static const int smallHeight = (HM_HEIGHT+factor-1)/factor;
			float[] lowResMap = new float[smallWidth * smallHeight];
			memset(lowResMap.ptr, 0, float.sizeof*smallWidth*smallHeight);

			for (int x=0; x < HM_WIDTH; x++) 
			{
				for (int y=0; y < HM_HEIGHT; y++) 
				{
					float v = precipitation.TCOD_heightmap_get_value(x,y);
					int ix = x/factor;
					int iy = y/factor;
					lowResMap[ix + iy*smallWidth ] += v;
				}
			}
			float coef = 1.0f/factor;
			for (int x=0; x < HM_WIDTH; x++)
			{
				for (int y=0; y < HM_HEIGHT; y++) 
				{
					float v=getInterpolatedFloat(lowResMap,x*coef,y*coef,smallWidth,smallHeight);
					precipitation.TCOD_heightmap_set_value(x,y,v);
				}
			}
		}

		void computeColors()
		{
			// alter map color using temperature & precipitation maps
			//map_data_t *md = &mapData[0];
			for (int yi = 0; yi < HM_HEIGHT; yi++) 
			{
				//genLog("y = ", yi);
		        for (int x=0; x < HM_WIDTH; x++) 
		        {
		        	//genLog("1 ", x, " ", yi, " ", HM_WIDTH, " ", HM_HEIGHT);
					float h = hm.TCOD_heightmap_get_value(x,yi);
					//genLog("1.1.1 y = ", yi);
					float temp = temperature.TCOD_heightmap_get_value(x,yi);
					//genLog("1.1.2 y = ", yi);
					EBiome biome = biomeMap[x+yi*HM_WIDTH];
					TCOD_color_t c;
					//genLog("1.1 y = ", yi, " h < sandHeight ", h < sandHeight);
					if (h < sandHeight ) c = getMapColor(h);
					else 
					{
						c = getMapColor(h);
						//genLog("1.2.1 y = ", yi);
		                c = TCOD_color_lerp(c, getBiomeColor(biome,x,yi), 0.5f);
		                //genLog("1.2.2 y = ", yi);
					}
					//genLog("2 y = ", yi);
					// snow near poles
					temp += 10*(clouds[HM_WIDTH-1-x][HM_HEIGHT-1-yi]); // cheap 2D noise ;)
					//genLog("2.1 y = ", yi);
					if ( temp < -10.0f && h < sandHeight ) 
					{
						TCOD_image_put_pixel(worldmap, x, yi, TCOD_color_lerp(TCOD_color_t(255, 255, 255), c, 0.3f));
						//genLog("2.deep y = ", yi, " worldmap = ", worldmap);
					}
					else if ( temp < -8.0f && h < sandHeight ) 
					{
						TCOD_image_put_pixel(worldmap, x, yi, TCOD_color_lerp(TCOD_color_t(255, 255, 255), c, 0.3f + 0.7f * (10.0f+temp)/2.0f));
						//genLog("2.hallow y = ", yi, " worldmap = ", worldmap);
					}
					else if ( temp < -2.0f && h >= sandHeight) 
					{
						TCOD_image_put_pixel(worldmap, x, yi, TCOD_color_t(255, 255, 255));
						//genLog("2.very hallow y = ", yi, " worldmap = ", worldmap);
					}
					else if ( temp < 2.0f && h >= sandHeight ) 
					{
						//TCODColor snow = mapGradient[cast(int)(snowHeight*255) + cast(int)((255 - cast(int)(snowHeight*255)) * (0.6f-temp)/0.4f)];
						c = TCOD_color_lerp(TCOD_color_t(255, 255, 255), c, (temp+2)/4.0f);
						TCOD_image_put_pixel(worldmap, x, yi, c);
						//genLog("2.beach y = ", yi, " worldmap = ", worldmap);
					} else 
					{
						TCOD_image_put_pixel(worldmap, x, yi, c);
						//genLog("2.earth y = ", yi, " worldmap = ", worldmap);
					}
					//genLog("3 y = ", yi);
				}
			}
			
			// draw rivers
			/*
			for (river_t **it=rivers.begin(); it != rivers.end(); it++) 
			{
			    for (int i=0; i < (*it).coords.size(); i++ ) 
			    {
			        int coord = (*it).coords.get(i);
			        int strength = (*it).strength.get(i);
			        int x = coord % HM_WIDTH;
			        int y = coord / HM_WIDTH;
			        TCODColor c= worldmap.getPixel(x,y);
			        c = TCODColor.lerp(c,TCODColor.blue,(float)(strength)/5.0f);
			        worldmap.putPixel(x,y,c);
			    }
			}
			*/
			genLog("Drawing rivers");
			foreach(river; rivers)
			{
				size_t i = 0;
				foreach(coord; river.coords)
				{
					int strength = river.strength[i];
			        int x = coord % HM_WIDTH;
			        int y = coord / HM_WIDTH;
			        TCOD_color_t c = worldmap.TCOD_image_get_pixel(x,y);
			        c = TCOD_color_lerp(c, TCOD_color_t(0,0,255),cast(float)(strength)/5.0f);
			        worldmap.TCOD_image_put_pixel(x,y,c);

					i++;
				}
			}

			/*size_t im = 0;
			map_data_t md = mapData[im];
			for (int y=0; y < HM_HEIGHT; y++) 
			{
		        for (int x=0; x < HM_WIDTH; x++) 
		        {
		        	genLog("1");
		            if ( md.riverId > 0 ) 
		            {
		            	genLog("2");
		                TCOD_color_t c = TCOD_image_get_pixel(worldmap, x,y);
		                c = TCOD_color_lerp(c, TCOD_color_t(0,0,255), 0.3f);
		                TCOD_image_put_pixel(worldmap, x,y,c);
		            }
		            genLog("3");
		            im++;
		            md = mapData[im];
		        }
			}*/

			genLog("Blur");
			// blur
			static const int[] dx = [0,-1,0,1,0];
			static const int[] dy = [0,0,-1,0,1];
			static const int[] coef = [1,2,2,2,2];
			for (int x=0; x < HM_WIDTH; x++) 
			{
				for (int y=0; y < HM_HEIGHT; y++)
				 {
			        int r=0,g=0,b=0,count=0;
				    for (size_t i=0; i < 5; i++) 
				    {
				        int ix=x+dx[i];
				        int iy=y+dy[i];
				        if (inRectangle(ix,iy,HM_WIDTH,HM_HEIGHT))
				        {
				            TCOD_color_t c = worldmap.TCOD_image_get_pixel(ix,iy);
				            r += coef[i]*c.r;
				            g += coef[i]*c.g;
				            b += coef[i]*c.b;
				            count += coef[i];
				        }
				    }
		            r /= count;
		            g /= count;
		            b /= count;
		            TCOD_image_put_pixel(worldmap, x, y, TCOD_color_t(cast(ubyte)r,cast(ubyte)g,cast(ubyte)b));
				}
			}
			drawCoasts(worldmap);
			genLog("computeColors finished");
		}

		void drawCoasts(TCOD_image_t img)
		{
		    // detect coasts
		    for (int x=0; x < HM_WIDTH-1; x++) 
		    {
		        for (int y=0; y < HM_HEIGHT-1; y++) 
		        {
		            float h = hm.TCOD_heightmap_get_value(x,y);
		            float h2 = hm.TCOD_heightmap_get_value(x+1,y);
		            if ( ( h < sandHeight && h2 >= sandHeight )
		                || ( h2 < sandHeight && h >= sandHeight ) ) 
		                	TCOD_image_put_pixel(img, x, y, TCOD_color_t(0,0,0));
		            else 
		            {
		                h = hm.TCOD_heightmap_get_value(x,y);
		                h2 = hm.TCOD_heightmap_get_value(x,y+1);
		                if ( ( h < sandHeight && h2 >= sandHeight )
		                    || ( h2 < sandHeight && h >= sandHeight ) ) 
		                    	TCOD_image_put_pixel(img, x, y, TCOD_color_t(0,0,0));
		            }
		        }
		    }			
		}

		EClimate getClimateFromTemp(float temp)
		{
		    if ( temp <= -5 ) return EClimate.ARTIC_ALPINE;
		    if ( temp <= 5 )  return EClimate.COLD;
		    if ( temp <= 15 ) return EClimate.TEMPERATE;
		    if ( temp <= 20 ) return EClimate.WARM;
		    return EClimate.TROPICAL;			
		}
	}	
}