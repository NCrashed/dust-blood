// Written in D programming language
/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module util.worldgen;

// world generator
// this was mostly generated with libtcod 1.4.2 heightmap tool !

import derelict.tcod.libtcod;
import std.math;
import std.stdio;

public
{
	// size of the heightmap
	enum HM_WIDTH = 400;
	enum HM_HEIGHT = 400;

	// biome and climate list. based on Whittaker Biome Diagram
	enum EClimate {
	    ARTIC_ALPINE,
	    COLD,
	    TEMPERATE,
	    WARM,
	    TROPICAL,
	    NB_CLIMATES
	};

	// grassland : might be either grassland, shrubland or woodland depending on the vegetation level
	// savanna : might be either savanna or thorn forest depending on the vegetation level
	enum EBiome {
		TUNDRA,
	    COLD_DESERT, GRASSLAND, BOREAL_FOREST,
	    TEMPERATE_FOREST, TROPICAL_MONTANE_FOREST,
	    HOT_DESERT, SAVANNA, TROPICAL_DRY_FOREST, TROPICAL_EVERGREEN_FOREST,
	    THORN_FOREST,
	    NB_BIOMES
	};	
}
package
{
	void dbg(T...)(T args)
	{
		debug writeln(text(args));
	}

	// temperature / precipitation Biome diagram (Whittaker diagram)
	EBiome biomeDiagram[5][5] = [
	    // artic/alpine climate (below -5°C)
	    [ TUNDRA, TUNDRA, TUNDRA, TUNDRA, TUNDRA, ],
	    // cold climate (-5 / 5 °C)
	    [ COLD_DESERT, GRASSLAND, BOREAL_FOREST, BOREAL_FOREST, BOREAL_FOREST, ],
	    // temperate climate (5 / 15 °C)
	    [ COLD_DESERT, GRASSLAND, TEMPERATE_FOREST, TEMPERATE_FOREST, TROPICAL_MONTANE_FOREST, ],
	    // warm climate (15 - 20°C)
	    [ HOT_DESERT, SAVANNA, TROPICAL_DRY_FOREST, TROPICAL_EVERGREEN_FOREST, TROPICAL_EVERGREEN_FOREST, ],
	    // tropical climate (above 20 °C)
	    [ HOT_DESERT, THORN_FOREST, TROPICAL_DRY_FOREST, TROPICAL_EVERGREEN_FOREST, TROPICAL_EVERGREEN_FOREST, ],
	];

	enum sandHeight		=	0.12f;
	enum grassHeight	=	0.16f; //0.315f;
	enum rockHeight		=	0.655f;
	enum snowHeight		=	0.905f; //0.785f;

	// TCOD's land color map
	enum MAX_COLOR_KEY	=	10;

	enum COLOR_KEY_MAX_SEA = 	(cast(int)(sandHeight*255)-1);
	enum COLOR_KEY_MIN_LAND = 	(cast(int)(sandHeight*255));

	static const int keyIndex[MAX_COLOR_KEY] = [0,
		COLOR_KEY_MAX_SEA,
		COLOR_KEY_MIN_LAND,
		cast(int)(grassHeight*255),
		cast(int)(grassHeight*255)+10,
		cast(int)(rockHeight*255),
		cast(int)(rockHeight*255)+10,
		cast(int)(snowHeight*255),
		cast(int)(snowHeight*255)+10,
		255
	];
	static const TCODColor keyColor[MAX_COLOR_KEY]= [
		TCODColor(0,0,50),    	// deep water
		TCODColor(20,20,200), 	// water-sand transition
		TCODColor(134,180,101),	// sand
		TCODColor(80,120,10),	// sand-grass transition
		TCODColor(17,109,7), 	// grass
		TCODColor(30,85,12), 	// grass-rock transisiton
		TCODColor(64,70,20), 	// rock
		TCODColor(120,140,40), 	// rock-snow transisiton
		TCODColor(208,208,239), // snow
		TCODColor(255,255,255)
	];

	// altitude color map
	enum MAX_ALT_KEY	=	8;
	static const int altIndexes[MAX_ALT_KEY] = [
		0,15,cast(int)(sandHeight*255),cast(int)(sandHeight*255)+1,
		80,130,195,255
		];
	static const float altitudes[MAX_ALT_KEY] = [
	     -2000,-1000,-100,0,500,1000,2500,4000	// in meters
		];
	static const TCODColor altColors[MAX_ALT_KEY]= [
		TCODColor(24,165,255), 	// -2000
		TCODColor(132,214,255), // -1000
		TCODColor(247,255,255), // -100
		TCODColor(49,149,44), 	// 0
		TCODColor(249,209,151), // 500
		TCODColor(165,148,24), 	// 1000
		TCODColor(153,110,6), 	// 2500
		TCODColor(172,141,138), // 4000
	];

	// precipitation color map
	enum MAX_PREC_KEY	=	19;
	static const int precIndexes[MAX_PREC_KEY] = [
		4,8,12,16,20,24,28,32,36,40,50,60,70,80,100,120,140,160,255
		];
	static const float precipitations[MAX_PREC_KEY] = [
		0,1,2,3,4,5,6,7,8,9,10,13,15,18,20,25,30,35,40  // cm / m² / year
	];
	static const TCODColor precColors[MAX_PREC_KEY]= [
		TCODColor(128,0,0), 	// < 4
		TCODColor(173,55,0), 	// 4-8
		TCODColor(227,102,0), 	// 8-12
		TCODColor(255,149,0), 	// 12-16
		TCODColor(255,200,0), 	// 16-20
		TCODColor(255,251,0), 	// 20-24
		TCODColor(191,255,0), 	// 24-28
		TCODColor(106,251,0), 	// 28-32
		TCODColor(25,255,48), 	// 32-36
		TCODColor(48,255,141), 	// 36-40
		TCODColor(28,255,232), 	// 40-50
		TCODColor(54,181,255), 	// 50-60
		TCODColor(41,71,191), 	// 60-70
		TCODColor(38,0,255), 	// 70-80
		TCODColor(140,0,255), 	// 80-100
		TCODColor(221,0,255), 	// 100-120
		TCODColor(255,87,255), 	// 120-140
		TCODColor(255,173,255), // 140-160
		TCODColor(255,206,255), // > 160
	];

	// temperature color map
	enum MAX_TEMP_KEY	=	7;
	static const int tempIndexes[MAX_TEMP_KEY] = [0,42,84,126,168,210,255];
	static const int temperatures[MAX_TEMP_KEY] = [-30,-20,-10,0,10,20,30];
	static const TCODColor tempKeyColor[MAX_TEMP_KEY]= [
		TCODColor(180,8,130), 	// -30 °C
		TCODColor(32,1,139), 	// -20 °C
		TCODColor(0,65,252),	// -10 °C
		TCODColor(37,255,236),	// 0 °C
		TCODColor(255,255,1), 	// 10 °C
		TCODColor(255,29,4), 	// 20 °C
		TCODColor(80,3,0), 		// 30 °C
	];

	static T clamp(T min, T max, T val) pure nothrow
	{
		return val < min ? min : (val > max ? max : val);
	}

	static bool inRectangle(int x, int y, int w, int h) pure nothrow
	{
		return (cast(uint)(x) < cast(uint)(w) && cast(uint)(y) < cast(uint)(h));
	}

	static double sqrdist(double x1, double y1, double x2, double y2)
	{
		return (((x1)-(x2))*((x1)-(x2))+((y1)-(y2))*((y1)-(y2)));
	}	
}

class WorldGenerator 
{
	public
	{
		// altitude->color map
		TCODColor mapGradient[256];
		// world height map (0.0 - 1.0)
		TCODHeightMap *hm;
		// height map without erosion
		TCODHeightMap *hm2;
		// complete world map (not shaded)
		TCODImage *worldmap;
		// temperature map (in °C)
		TCODHeightMap *temperature;
		// precipitation map (0.0 - 1.0)
		TCODHeightMap *precipitation;
		// biome map
		EBiome *biomeMap;

		void generate(TCODRandom *wRng)
		{
			float t00, t0=TCODSystem.getElapsedSeconds();
			t00=t0;
		    cloudDx=cloudTotalDx=0.0f;
			TCODColor.genMap(mapGradient,MAX_COLOR_KEY,keyColor,keyIndex);
			if ( wRng == NULL ) wRng=TCODRandom.getInstance();
			wgRng = wRng;
			noise=new TCODNoise(2,wgRng);
			hm=new TCODHeightMap(HM_WIDTH,HM_HEIGHT);
			hm2=new TCODHeightMap(HM_WIDTH,HM_HEIGHT);
			worldmap = new TCODImage(HM_WIDTH,HM_HEIGHT);
			worldint = new float[HM_WIDTH*HM_HEIGHT];
			temperature =  new TCODHeightMap(HM_WIDTH,HM_HEIGHT);
			precipitation = new TCODHeightMap(HM_WIDTH,HM_HEIGHT);
			biomeMap = new EBiome[HM_WIDTH*HM_HEIGHT];
			mapData = new map_data_t[HM_WIDTH*HM_HEIGHT];
			memset(mapData,0,sizeof(map_data_t)*HM_WIDTH*HM_HEIGHT);
			float t1=TCODSystem.getElapsedSeconds();
			DBG(("Initialization... %g\n", t1-t0 ));
			t0=t1;

			buildBaseMap();
			t1=TCODSystem.getElapsedSeconds();
			DBG(("Heightmap construction... %g\n", t1-t0 ));
			t0=t1;

			computePrecipitations();
			t1=TCODSystem.getElapsedSeconds();
			DBG(("Precipitation map... %g\n", t1-t0 ));
			t0=t1;

			erodeMap();
			t1=TCODSystem.getElapsedSeconds();
			DBG(("Erosion... %g\n", t1-t0 ));
			t0=t1;

			smoothMap();
			t1=TCODSystem.getElapsedSeconds();
			DBG(("Smooth... %g\n", t1-t0 ));
			t0=t1;

		    setLandMass(0.6f,sandHeight);

			for (int i=0; i < HM_WIDTH*HM_HEIGHT/3000; i++) {
		//	for (int i=0; i < 1; i++) {
				generateRivers();
			}
			t1=TCODSystem.getElapsedSeconds();
			DBG(("Rivers... %g\n", t1-t0 ));
			t0=t1;

		    smoothPrecipitations();
			t1=TCODSystem.getElapsedSeconds();
			DBG(("Smooth precipitations... %g\n", t1-t0 ));
			t0=t1;

			computeTemperaturesAndBiomes();
			t1=TCODSystem.getElapsedSeconds();
			DBG(("Temperature map... %g\n", t1-t0 ));
			t0=t1;

			computeColors();
			t1=TCODSystem.getElapsedSeconds();
			DBG(("Color map... %g\n", t1-t0 ));
			t0=t1;

			t1=TCODSystem.getElapsedSeconds();
			DBG(("TOTAL TIME... %g\n", t1-t00 ));			
		}

		int width() @property const
		{
			return HM_WIDTH;
		}

		int height() @property const
		{
			return HM_HEIGHT;
		}

		float getAltitude(int x, int y) const
		{
			return hm.getValue(x,y);
		}

		float getInterpolatedAltitude(float x, float y) const
		{
			return hm.getInterpolatedValue(x, y);
		}

		float getSandHeight() const
		{
			return sandHeight;
		}

		bool isOnSea(float x, float y) const
		{
			return getInterpolatedAltitude(x, y) <= sandHeight;
		}

		float getCloudThickness(float x, float y) const
		{
		    x += cloudDx;
		    int ix=cast(int)x;
		    int iy=cast(int)y;
		    int ix1 = cast(int)fmin(HM_WIDTH-1,ix+1);
		    int iy1 = cast(int)fmax(HM_HEIGHT-1,iy+1);
		    float fdx = x - ix;
		    float fdy = y - iy;
		    float v1 = clouds[ix][iy];
		    float v2 = clouds[ix1][iy];
		    float v3 = clouds[ix][iy1];
		    float v4 = clouds[ix1][iy1];
		    float vx1 = ((1.0f - fdx) * v1 + fdx * v2);
		    float vx2 = ((1.0f - fdx) * v3 + fdx * v4);
		    float v = ((1.0f - fdy) * vx1 + fdy * vx2);
		    return v;			
		}

		void getInterpolatedNormal(float x, float y, float n[3]) const
		{
			return hm2.getNormal(x,y,n,sandHeight);
		}

		TCODColor getInterpolatedColor(float worldX, float worldY)
		{
			return getInterpolatedColor(worldmap, worldX, worldY);
		}

		float getInterpolatedIntensity(float worldX, float worldY)
		{
			return getInterpolatedFloat(worldint,worldX,worldY,HM_WIDTH,HM_HEIGHT);
		}

		// update
		void updateClouds(float elapsedTime)
		{
		    cloudTotalDx += elapsedTime * 5;
		    cloudDx += elapsedTime * 5;
		    if ( cloudDx >= 1.0f ) 
		    {
		        int colsToTranslate = cast(int)cloudDx;
		        cloudDx -= colsToTranslate;
		        // translate the cloud map
		        for ( int x=colsToTranslate; x < HM_WIDTH; x++) 
		        {
		            for (int y=0; y < HM_HEIGHT; y++) {
		                clouds[x-colsToTranslate][y]=clouds[x][y];
		            }
		        }
		        // compute a new column
		        float f[2];
		        float cdx = cast(int)cloudTotalDx ;
		        for ( int x = HM_WIDTH-colsToTranslate; x < HM_WIDTH; x++) {
		            for (int y = 0; y < HM_HEIGHT; y++) {
		                f[0] = 6.0f*(cast(float)(x+cdx) / HM_WIDTH);
		                f[1] = 6.0f*(cast(float)(y) / HM_HEIGHT);
		                clouds[x][y] = 0.5f * (1.0f + 0.8f * noise.getFbmSimplex(f,4.0f));
		            }
		        }
		    }
		}

		void computeSunLight(float lightDir[3])
		{
			for (int x=0; x < HM_WIDTH; x++) 
			{
				for (int y=0; y < HM_HEIGHT; y++) 
				{
					worldint[x+y*HM_WIDTH]=getMapIntensity(x+0.5f,y+0.5f,lightDir);
				}
			}			
		}
		
		// data
		float getRealAltitude(float x, float y) const // in meters
		{
			int ih = cast(int)(256*getInterpolatedAltitude(x,y));
			ih = clamp(0,255,ih);
			foreach(size_t idx; 0..MAX_ALT_KEY-1)
			{
				if(altIndexes[idx+1] > ih) break;
			}
			float alt = altitudes[idx] + (altitudes[idx+1]-altitudes[idx]) 
				* (ih - altIndexes[idx]) / (altIndexes[idx+1]-altIndexes[idx]);
		}

		float getPrecipitations(float x, float y) const // in centimeter/m²/year
		{
			int iprec = cast(int)(256*precipitation.getValue(cast(int)x,cast(int)y));
			iprec=clamp(0,255,iprec);
			foreach(size_t idx; 0..MAX_PREC_KEY-1)
			{
				if ( precIndexes[idx+1] > iprec ) break;
			}

			float prec = precipitations[idx] + (precipitations[idx+1]-precipitations[idx]) * (iprec-precIndexes[idx])/(precIndexes[idx+1]-precIndexes[idx]);
			return prec;			
		}

		float getTemperature(float x, float y) const // in °C
		{
			return temperature.getValue(cast(int)x,cast(int)y);
		}

		EBiome getBiome(float x, float y) const
		{
			return biomeMap[cast(int)x+cast(int)y*HM_WIDTH];
		}

		// map generators
		void saveBiomeMap(string filename = "")
		{
		    static TCODImage *legend = null;
		    static int legendHeight, legendWidth;
		    static const TCODColor biomeColors[] = [
			    // TUNDRA,
			    TCODColor(88,234,250),
			    // COLD_DESERT,
			    TCODColor(129,174,170),
			    // GRASSLAND,
			    TCODColor.sea,
			    // BOREAL_FOREST,
			    TCODColor(14,93,43),
			    // TEMPERATE_FOREST,
			    TCODColor(44,177,83),
			    // TROPICAL_MONTANE_FOREST,
			    TCODColor(185,232,164),
			    // HOT_DESERT,
			    TCODColor(229,247,184),
			    // SAVANNA,
			    TCODColor.orange,
			    // TROPICAL_DRY_FOREST,
			    TCODColor.darkYellow,
			    // TROPICAL_EVERGREEN_FOREST,
			    TCODColor.green,
			    // THORN_FOREST,
			    TCODColor(192,192,112),
		    ];

		    if ( legend is null ) 
		    {
		        legend = new TCODImage("data/img/legend_biome.png");
		        legend.getSize(&legendWidth,&legendHeight);
		    }

		    if ( filename == "" ) filename="world_biome.png";

		    TCODImage img = TCODImage(cast(int)fmax(HM_WIDTH,legendWidth),HM_HEIGHT+legendHeight);
		    // draw biome map
			for (size_t x=0; x < HM_WIDTH; x++) 
			{
				for (size_t y=0; y < HM_HEIGHT; y++) 
				{
				    float h = hm.getValue(x,y);
				    if ( h < sandHeight ) img.putPixel(x,y,TCODColor(100,100,255));
				    else img.putPixel(x, y, biomeColors[biomeMap[x+y*HM_WIDTH]]);
				}
			}
			drawCoasts(&img);

			// blit legend
			int legendx = cast(int)fmax(HM_WIDTH,legendWidth) / 2 - legendWidth/2;
			for (size_t x=0; x < legendWidth; x++) 
			{
				for (size_t y=0; y < legendHeight; y++) 
				{
				    img.putPixel(legendx+x, HM_HEIGHT+y, legend.getPixel(x,y));
				}
			}

			// fill legend colors
			for (size_t i=0; i < 6; i++ ) 
			{
		        for (int x=17; x < 47; x++)
		            for (int y=4+i*14; y < 14+i*14; y++ )
		                img.putPixel(legendx+x,HM_HEIGHT+y,biomeColors[i]);
			}
			for (size_t i=6; i < NB_BIOMES; i++ ) 
			{
		        for (int x=221; x < 251; x++)
		            for (int y=4+(i-6)*14; y < 14+(i-6)*14; y++ )
		                img.putPixel(legendx+x,HM_HEIGHT+y,biomeColors[i]);
			}
			img.save(filename);
		}

		void saveAltitudeMap(string filename = "")
		{
		    static TCODColor altGradient[256];

		    static TCODImage *legend = null;
		    static int legendHeight,legendWidth;

		    if ( legend is null ) 
		    {
		        legend = new TCODImage("data/img/legend_altitude.png");
		        legend.getSize(&legendWidth,&legendHeight);
		        TCODColor.genMap(altGradient,MAX_ALT_KEY,altColors,altIndexes);
		    }

		    if ( filename == "" ) filename="world_altitude.png";

		    TCODImage img = TCODImage(HM_WIDTH+legendWidth,cast(int)fmax(HM_HEIGHT,legendHeight));
		    
		    // render altitude map
		    for (int x=0; x < HM_WIDTH; x++) 
		    {
		        for (int y=0; y < HM_HEIGHT; y++) 
		        {
		            float h=hm.getValue(x,y);
		            size_t ialt = cast(size_t)(h * 256);
		            ialt = clamp(0,255,ialt);
		            img.putPixel(x,y,altGradient[ialt]);
		        }
		    }

			// blit legend
			int legendy = MAX(HM_HEIGHT,legendHeight) / 2 - legendHeight/2;
			for (int x=0; x < legendWidth; x++) 
			{
				for (int y=0; y < legendHeight; y++) 
				{
				    img.putPixel(HM_WIDTH+x,legendy+y,legend.getPixel(x,y));
				}
			}
		    img.save(filename);
		}

		void saveTemperatureMap(string filename = "")
		{
		    static TCODColor tempGradient[256];

		    static TCODImage *legend = null;
		    static int legendHeight,legendWidth;
		    if ( legend == null ) 
		    {
		        legend = new TCODImage("data/img/legend_temperature.png");
		        legend.getSize(&legendWidth,&legendHeight);
		        TCODColor.genMap(tempGradient, MAX_TEMP_KEY, tempKeyColor, tempIndexes);
		    }

		    if ( filename == "" ) filename="world_temperature.png";

		    TCODImage img = TCODImage(MAX(HM_WIDTH,legendWidth), HM_HEIGHT+legendHeight);

		    float minTemp,maxTemp;
		    temperature.getMinMax(&minTemp,&maxTemp);

		    // render temperature map
		    for (int x=0; x < HM_WIDTH; x++) 
		    {
		        for (int y=0; y < HM_HEIGHT; y++) 
		        {
				    float h = hm.getValue(x,y);
				    if ( h < sandHeight ) img.putPixel(x, y, TCODColor(100,100,255));
				    else 
				    {
			            float temp=temperature.getValue(x,y);
			            temp = (temp - minTemp) / (maxTemp-minTemp);
			            int colorIdx = cast(int)(temp*255);
			            colorIdx = clamp(0,255,colorIdx);
			            img.putPixel(x,y,tempGradient[colorIdx]);
			        }
		        }
		    }
		    drawCoasts(&img);

			// blit legend
			int legendx = MAX(HM_WIDTH,legendWidth) / 2 - legendWidth/2;
			for (int x=0; x < legendWidth; x++) {
				for (int y=0; y < legendHeight; y++) {
				    img.putPixel(legendx+x,HM_HEIGHT+y,legend.getPixel(x,y));
				}
			}
		    img.save(filename);
		}

		void savePrecipitationMap(string filename = "")
		{
		    static TCODImage *legend = null;
		    static int legendHeight,legendWidth;
		    if ( legend is null ) 
		    {
		        legend = new TCODImage("data/img/legend_precipitation.png");
		        legend.getSize(&legendWidth,&legendHeight);
		    }

		    if ( filename == "" ) filename="world_precipitation.png";

		    TCODImage img = TCODImage(MAX(HM_WIDTH,legendWidth),HM_HEIGHT+legendHeight);

		    // render precipitation map
		    for (int x=0; x < HM_WIDTH; x++) 
		    {
		        for (int y=0; y < HM_HEIGHT; y++) 
		        {
				    float h = hm.getValue(x,y);
				    if ( h < sandHeight ) img.putPixel(x, y, TCODColor(100,100,255));
				    else 
				    {
			            float prec=precipitation.getValue(x,y);
			            int iprec = cast(int)(prec * 180);
			            int colorIdx=0;
			            while (colorIdx < MAX_PREC_KEY && iprec > precIndexes[colorIdx]) colorIdx++;
			            colorIdx = clamp(0,MAX_PREC_KEY,colorIdx);
			            img.putPixel(x,y,precColors[colorIdx]);
			        }
		        }
		    }
		    drawCoasts(&img);

			// blit legend
			int legendx = cast(int)fmax(HM_WIDTH,legendWidth) / 2 - legendWidth/2;
			for (int x=0; x < legendWidth; x++) 
			{
				for (int y=0; y < legendHeight; y++) 
				{
				    img.putPixel(legendx+x, HM_HEIGHT+y, legend.getPixel(x,y));
				}
			}
		    img.save(filename);
		}

	}
	protected
	{
		class RiverPathCbk : ITCODPathCallback 
		{
		    float getWalkCost( int xFrom, int yFrom, int xTo, int yTo, void *userData ) const 
		    {
		        WorldGenerator *world = cast(WorldGenerator *)userData;
		        float h1 = world.hm.getValue(xFrom,yFrom);
		        float h2 = world.hm.getValue(xTo,yTo);
		        if ( h2 < sandHeight ) return 0.0f;
				// float f[2] = {xFrom*10.0f/HM_WIDTH,yFrom*10.0f/HM_HEIGHT};
				// return (1.0f+h2-h1)*10+5*(1.0f+noise2d.getSimplex(f));
		        return (0.01f+h2-h1)*100;
		    }
		};

		TCODNoise *noise;
		// cloud thickness
		float clouds[HM_WIDTH][HM_HEIGHT];
		float cloudDx; // horizontal offset for smooth scrolling
		float cloudTotalDx;
		// world light intensity map (shadow map)
		float *worldint;

		struct map_data_t
		{
			float slope;
			// number of cells flowing into this cell
			uint area;
			// direction of lowest neighbour
			ubyte flowDir;
			// inverse flow direction
			ubyte upDir;
			ubyte inFlags; // incoming flows
			ubyte riverId;
			int riverLength;
		}
		map_data_t * mapData;

		struct river_t
		{
		    TCODList!int coords;
		    TCODList!int strength;
		}
		TCODList!(river_t *) rivers;
		TCODRandom *wgRng;		
	}
	protected
	{
		void addHill(int nbHill, float baseRadius, float radiusVar, float height)
		{
			for (int i=0; i< nbHill; i++ ) 
			{
				float hillMinRadius = baseRadius*(1.0f-radiusVar);
				float hillMaxRadius = baseRadius*(1.0f+radiusVar);
				float radius = wgRng.getFloat(hillMinRadius, hillMaxRadius);
				int xh = wgRng.getInt(0,HM_WIDTH-1);
				int yh = wgRng.getInt(0,HM_HEIGHT-1);
				hm.addHill(cast(float)xh,cast(float)yh,radius,height);
			}
		}

		void buildBaseMap()
		{
			float t0 = TCODSystem.getElapsedSeconds();
			addHill(600,16.0*HM_WIDTH/200,0.7,0.3);
			hm.normalize();
			float t1 = TCODSystem.getElapsedSeconds();

			DBG(("  Hills... %g\n", t1-t0 ));
			t0=t1;

			hm.addFbm(noise,2.20*HM_WIDTH/400,2.20*HM_WIDTH/400,0,0,10.0f,1.0,2.05);
			hm.normalize();
			hm2.copy(hm);
			t1 = TCODSystem.getElapsedSeconds();

			DBG(("  Fbm... %g\n", t1-t0 ));
			t0=t1;

		    setLandMass(0.6f,sandHeight);

			// fix land/mountain ratio using x^3 curve above sea level
			for ( int x=0; x < HM_WIDTH; x++) 
			{
			    for (int y=0; y < HM_HEIGHT; y++) 
			    {
					float h = hm.getValue(x,y);
					if ( h >= sandHeight ) 
					{
		                float coef = (h-sandHeight) / (1.0f - sandHeight);
					    h = sandHeight + coef * coef * coef * (1.0f - sandHeight);
					    hm.setValue(x,y,h);
					}
			    }
			}

			t1=TCODSystem.getElapsedSeconds();
			DBG(("  Flatten plains... %g\n", t1-t0 ));
			t0=t1;

			// we use a custom erosion algo
			//hm.rainErosion(15000*HM_WIDTH/400,0.03,0.01,wgRng);
			//t1=TCODSystem.getElapsedSeconds();
			//DBG(("  Erosion... %g\n", t1-t0 ));
			//t0=t1;

			// compute clouds
			float f[2];
			for ( int x=0; x < HM_WIDTH; x++) 
			{
		        f[0] = 6.0f*(cast(float)(x) / HM_WIDTH);
			    for (int y=0; y < HM_HEIGHT; y++) 
			    {
		            f[1] = 6.0f*(cast(float)(y) / HM_HEIGHT);
		            clouds[x][y] = 0.5f * (1.0f + 0.8f * noise.getFbmSimplex(f,4.0f));
			    }
			}
			t1 = TCODSystem.getElapsedSeconds();
			DBG(("  Init clouds... %g\n", t1-t0 ));
			t0 = t1;
		}

		void erodeMap()
		{
			TCODHeightMap newMap = TCODHeightMap(HM_WIDTH,HM_HEIGHT);
			for (int i=5; i != 0; i --) 
			{
				// compute flow and slope maps
				map_data_t *md = mapData;
				for (int y=0; y < HM_HEIGHT; y++) 
				{
		            for (int x=0; x < HM_WIDTH; x++) 
		            {
						float h = hm.getValue(x,y);
						float hmin = h, hmax = h;
						int minDir = 0, maxDir = 0;
						for (int i=1; i< 9; i++ ) 
						{
							int ix = x+dirx[i];
							int iy = y+diry[i];
							if ( IN_RECTANGLE(ix,iy,HM_WIDTH,HM_HEIGHT)) 
							{
								float h2 = hm.getValue(ix,iy);
								if ( h2 < hmin ) 
								{
									hmin = h2;
									minDir = i;
								} else if ( h2 > hmax ) 
								{
									hmax = h2;
									maxDir = i;
								}
							}
						}
						md.flowDir = minDir;
						md.upDir = maxDir;
						float slope = hmin - h; // this is negative
						slope *= dircoef[minDir];
						md.slope = slope;
						md++;
					}
				}

				md=mapData;
				for (int y=0; y < HM_HEIGHT; y++) 
				{
		            for (int x=0; x < HM_WIDTH; x++) 
		            {
		                float sediment = 0.0f;
		                bool end = false;
		                int ix = x, iy = y;
		                ubyte oldFlow = md.flowDir;
		                map_data_t *md2 = md;
		                while ( !end ) 
		                {
		                    float h = hm.getValue(ix,iy);
		                    if (h < sandHeight-0.01f) break;
		                    if ( md2.flowDir == oppdir[oldFlow] ) 
		                    {
		                        h += SEDIMENTATION_FACTOR * sediment;
		                        hm.setValue(ix,iy,h);
		                        end = true;
		                    } else 
		                    {
		                        // remember, slope is negative
		                        h += precipitation.getValue(ix,iy)* EROSION_FACTOR * md2.slope;
		                        h = cast(float)fmax(h,sandHeight);
		                        sediment -= md2.slope;
		                        hm.setValue(ix,iy,h);
		                        oldFlow = md2.flowDir;
		                        ix += dirx[oldFlow];
		                        iy += diry[oldFlow];
		                        md2 = &mapData[ix+iy*HM_WIDTH];
		                    }
		                }
		                md++;
					}
		        }
				DBG( ("  Erosion pass %d\n",i));

				// mudslides (smoothing)
				float sandCoef = 1.0f/(1.0f-sandHeight);
				for (int x=0; x < HM_WIDTH; x++) 
				{
					for (int y=0; y < HM_HEIGHT; y++) 
					{
						float h = hm.getValue(x,y);
						if ( h < sandHeight-0.01f || h >= MAX_EROSION_ALT ) 
						{
							newMap.setValue(x,y,h);
							continue;
						}
						float sumDelta1 = 0.0f, sumDelta2 = 0.0f;
						int nb1 = 1, nb2 = 1;
						for (int i=1; i < 9; i++ ) 
						{
							int ix = x+dirx[i];
							int iy = y+diry[i];
							if ( inRectangle(ix, iy, HM_WIDTH,HM_HEIGHT)) 
							{
								float ih = hm.getValue(ix,iy);
								if ( ih < h ) {
									if ( i ==1 || i == 3 || i == 6 || i == 8 ) {
										// diagonal neighbour
										sumDelta1 += (ih - h)*0.4f;
										nb1++;
									} else {
										// adjacent neighbour
										sumDelta2 += (ih -h)*1.6f;
										nb2++;
									}
								}
							}
						}
						// average height difference with lower neighbours
						float dh = sumDelta1/nb1 + sumDelta2/nb2;
						dh *= MUDSLIDE_COEF;
						float hcoef=(h-sandHeight)* sandCoef;
						dh *= (1.0f-hcoef*hcoef*hcoef); // less smoothing at high altitudes

						newMap.setValue(x,y,h+dh);
					}
				}
				hm.copy(&newMap);
			}
		}

		void smoothMap()
		{
			// 3x3 kernel for smoothing operations
			static const int smoothKernelSize = 9;
			static const int smoothKernelDx[9] = [-1,0,1,-1,0,1,-1,0,1];
			static const int smoothKernelDy[9] = [-1,-1,-1,0,0,0,1,1,1];
			static const float smoothKernelWeight[9] = [2,8,2,8,20,8,2,8,2];

			debug
			{
				float t0 = TCODSystem.getElapsedSeconds();
			}

			hm.kernelTransform(smoothKernelSize,smoothKernelDx,smoothKernelDy,smoothKernelWeight,-1000,1000);
			hm2.kernelTransform(smoothKernelSize,smoothKernelDx,smoothKernelDy,smoothKernelWeight,-1000,1000);
			hm.normalize();

			debug
			{
				float t1 = TCODSystem.getElapsedSeconds();
				DBG(("  Blur... %g\n", t1-t0 ));
			}
		}

		// compute the ground color from the heightmap
		TCODColor getMapColor(float h)
		{
			int colorIdx;
			if ( h < sandHeight ) colorIdx = cast(int)(h/sandHeight * COLOR_KEY_MAX_SEA);
			else colorIdx = COLOR_KEY_MIN_LAND + cast(int)((h-sandHeight)/(1.0f-sandHeight) * (255-COLOR_KEY_MIN_LAND));
			colorIdx=clamp(0,255,colorIdx);
			return mapGradient[colorIdx];			
		}

		// get sun light intensity on a point of the map
		float getMapIntensity(float worldX,float worldY, float lightDir[3])
		{
		    // sun color & direction
		    static const TCODColor sunCol = TCODColor(255,255,160);
			float normal[3];
		    float wx = clamp(0.0f, HM_WIDTH-1,worldX);
		    float wy = clamp(0.0f, HM_HEIGHT-1,worldY);

			// apply sun light
		    getInterpolatedNormal(wx,wy,normal);
			normal[2] *= 3.0f;
		    float intensity = 0.75f
				- (normal[0]*lightDir[0]+normal[1]*lightDir[1]+normal[2]*lightDir[2])*0.75f;
			intensity=clamp(0.75f,1.5f,intensity);
			return intensity;			
		}
		
		TCODColor getInterpolatedColor(TCODImage *img, float x, float y) 
		{
			int w,h;
			img.getSize(&w,&h);
			float wx = clamp(0.0f, w-1,x);
			float wy = clamp(0.0f, h-1,y);
			int iwx = cast(int)wx;
			int iwy = cast(int)wy;
			float dx = wx - iwx;
			float dy = wy - iwy;

			TCODColor colNW = img.getPixel(iwx,iwy);
			TCODColor colNE = (iwx < w-1 ? img.getPixel(iwx+1,iwy) : colNW);
			TCODColor colSW = (iwy < h-1 ? img.getPixel(iwx,iwy+1) : colNW);
			TCODColor colSE = (iwx < w-1 && iwy < h-1 ? img.getPixel(iwx+1,iwy+1) : colNW);
			TCODColor colN = TCODColor.lerp(colNW,colNE,dx);
			TCODColor colS = TCODColor.lerp(colSW,colSE,dx);
			TCODColor col = TCODColor.lerp(colN,colS,dy);
			return col;
		}

		float getInterpolatedFloat(float *arr,float x,float y, int width, int height)
		{
			float wx = clamp(0.0f, width-1,x);
			float wy = clamp(0.0f, height-1,y);
			int iwx = cast(int)wx;
			int iwy = cast(int)wy;
			float dx = wx - iwx;
			float dy = wy - iwy;

			float iNW = arr[iwx+iwy*width];
			float iNE = (iwx < width-1 ? arr[iwx+1+iwy*width] : iNW);
			float iSW = (iwy < height-1 ? arr[iwx+(iwy+1)*width] : iNW);
			float iSE = (iwx < width-1 && iwy < height-1 ? arr[iwx+1+(iwy+1)*width] : iNW);
			float iN = (1.0f-dx)*iNW + dx*iNE;
			float iS = (1.0f-dx)*iSW + dx*iSE;
			return (1.0f-dy)*iN + dy * iS;			
		}

		void generateRivers()
		{
		    static int riverId = 0;
			// the source
			int sx,sy;
			// the destination
			int dx,dy;

			// get a random point near the coast
			sx = wgRng.getInt(0,HM_WIDTH-1);
			sy = wgRng.getInt(HM_HEIGHT/5,4*HM_HEIGHT/5);
			float h = hm.getValue(sx,sy);
			while ( h <  sandHeight - 0.02 || h >= sandHeight ) 
			{
				sx++;
				if ( sx == HM_WIDTH ) 
				{
					sx=0;
					sy++;
					if ( sy == HM_HEIGHT ) sy=0;
				}
				h = hm.getValue(sx,sy);
			}
			TCODList!int tree;
			TCODList!int randPt;
			tree.push(sx+sy*HM_WIDTH);
			riverId++;
			dx = sx;
			dy = sy;
			for (int i=0; i< wgRng.getInt(50,200); i++) 
			{
			    int rx = wgRng.getInt(sx-200,sx+200);
			    int ry = wgRng.getInt(sy-200,sy+200);
		//	    if ( inRectangle(rx,ry,HM_WIDTH,HM_HEIGHT) ) {
		//	        float h=hm.getValue(rx,ry);
		//	        if ( h >= sandHeight ) {
			            randPt.push(rx+ry*HM_WIDTH);
		//	        }
		//	    }
			}

		    for (int i=0; i < randPt.size(); i++) 
		    {
		        int rx = randPt.get(i)%HM_WIDTH;
		        int ry = randPt.get(i)/HM_WIDTH;

		        float minDist = 1E10;
		        int bestx = -1,besty = -1;
		        for (int j=0;j < tree.size(); j++) 
		        {
		            int tx=tree.get(j)%HM_WIDTH;
		            int ty=tree.get(j)/HM_WIDTH;
		            float dist = (tx-rx)*(tx-rx)+(ty-ry)*(ty-ry);
		            if ( dist < minDist) 
		            {
		                minDist=dist;
		                bestx=tx;
		                besty=ty;
		            }
		        }
		        TCODLine.init(bestx,besty,rx,ry);

		        int len = 3, cx = bestx, cy = besty;
		        map_data_t *md = &mapData[cx+cy*HM_WIDTH];

		        if (md.riverId == riverId ) md.riverId=0;
		        do 
		        {
		            md =& mapData[cx+cy*HM_WIDTH];
		            if (md.riverId > 0 ) return;
			        float h=hm.getValue(cx,cy);
			        if ( h >= sandHeight ) 
			        {
		                md.riverId = riverId;
		                precipitation.setValue(cx,cy,1.0f);
			        }
			        if (cx ==0 || cx == HM_WIDTH-1 || cy == 0 || cy == HM_HEIGHT-1 ) len = 0;
		            else if (TCODLine.step(&cx,&cy)) len=0;
		            len --;
		        } while(len > 0 );
		        int newNode = cx+cy*HM_WIDTH;
		        if (newNode != bestx+besty*HM_WIDTH ) 
		        {
		            tree.push(newNode);
		        }
		    }			
		}

		void smoothPrecipitations()
		{
			float t0 = TCODSystem.getElapsedSeconds();

			// better quality polishing blur using a 5x5 kernel
			// faster than TCODHeightmap kernelTransform function
			TCODHeightMap temphm = TCODHeightMap(HM_WIDTH, HM_HEIGHT);
			temphm.copy(precipitation);
			for (int i=4; i != 0; i--) 
			{
				for (int x=0; x < HM_WIDTH; x++) 
				{
					int minx = x - 2;
					int maxx = x + 2;
					int miny=0;
					int maxy=2;
					float sum=0.0f;
					int count=0;
					minx = cast(int)fmax( 0, minx );
					maxx = cast(int)fmin( HM_WIDTH-1, maxx);
					// compute the kernel sum at x,0
					for (int ix=minx; ix <= maxx; ix++) 
					{
						for (int iy =miny; iy <= maxy; iy++) 
						{
							sum += precipitation.getValue(ix,iy);
							count++;
						}
					}
					temphm.setValue(x,0,sum/count);

					for (int y=1; y < HM_HEIGHT; y++) 
					{
						if ( y-2 >= 0 ) 
						{
							// remove the top-line sum
							for (int ix=minx; ix <= maxx; ix++) 
							{
								sum -= precipitation.getValue(ix,y-2);
								count--;
							}
						}
						if ( y+2 < HM_HEIGHT ) 
						{
							// add the bottom-line sum
							for (int ix=minx; ix <= maxx; ix++) 
							{
								sum += precipitation.getValue(ix,y+2);
								count++;
							}
						}
						temphm.setValue(x,y,sum/count);
					}
				}
			}
			precipitation.copy(&temphm);

			float t1 = TCODSystem.getElapsedSeconds();
			DBG(("  Blur... %g\n", t1-t0 ));
			t0=t1;

			precipitation.normalize();
			t1 = TCODSystem.getElapsedSeconds();
			DBG(("  Normalization... %g\n", t1-t0 ));
			t0=t1;			
		}

		int getRiverStrength(int riverId)
		{
		    //river_t *river = rivers.get(riverId-1);
		    //return river.strength.get(river.strength.size()-1);
		    return 2;
		}

		void setLandMass(float percent, float waterLevel)
		{
			import std.c.string;

			// fix land mass. We want a proportion of landMass above sea level
			debug 
			{
				float t0=TCODSystem.getElapsedSeconds();
			}

			int heightcount[256];
			memset(heightcount.ptr,0,heightcount.length*int.sizeof);
			for ( int x=0; x < HM_WIDTH; x++) 
			{
			    for (int y=0; y < HM_HEIGHT; y++) 
			    {
					float h = hm.getValue(x,y);
					int ih = cast(int)(h*255);
					ih = clamp(0,255,ih);
					heightcount[ih]++;
				}
			}
			int i=0, totalcount=0;
			while (totalcount < HM_WIDTH*HM_HEIGHT*(1.0f-landMass) ) 
			{
				totalcount += heightcount[i];
				i++;
			}
			float newWaterLevel=i/255.0f;
			float landCoef = (1.0f-waterLevel)/(1.0f-newWaterLevel);
			float waterCoef = waterLevel / newWaterLevel;
			// water level should be rised/lowered to newWaterLevel
			for ( int x=0; x < HM_WIDTH; x++) 
			{
			    for (int y=0; y < HM_HEIGHT; y++) 
			    {
					float h = hm.getValue(x,y);
					if ( h > newWaterLevel ) 
					{
						h = waterLevel + (h-newWaterLevel)*landCoef;
					} else 
					{
						h = h * waterCoef;
					}
					hm.setValue(x,y,h);
				}
			}
			debug
			{
				float t1=TCODSystem.getElapsedSeconds();
				DBG(("  Landmass... %g\n", t1-t0 ));
			}
		}

		void computeTemperaturesAndBiomes()
		{
			// temperature shift with altitude : -25°C at 6000 m
			// mean temp at sea level : 25°C at lat 0  5°C at lat 45 -25°C at lat 90 (sinusoide)
			float sandCoef = 1.0f/(1.0f-sandHeight);
			float waterCoef = 1.0f/sandHeight;
			for (int y=0; y < HM_HEIGHT; y++) 
			{
				float lat = cast(float)(y-HM_HEIGHT/2) * 2 / HM_HEIGHT ;
				float latTemp = 0.5f*(1.0f+pow(sin(3.1415926*(lat+0.5f)),5)); // between 0 and 1
				if ( latTemp > 0.0f) latTemp = cast(float)sqrt(latTemp);
				latTemp = -30 + latTemp*60;
				for (int x=0; x < HM_WIDTH; x++) 
				{
					float h0 = hm.getValue(x,y);
					float h = h0 - sandHeight;
					if (h < 0.0f ) h *= waterCoef;
					else h *= sandCoef;
					float altShift = -35 * h;
					float temp = latTemp+altShift;
					temperature.setValue(x,y,temp);
					float humid = precipitation.getValue(x,y);
					// compute biome
					EClimate climate = getClimateFromTemp(temp);
					int iHumid = cast(int)(humid * 5);
					iHumid = cast(int)fmin(4,iHumid);
					EBiome biome = biomeDiagram[climate][iHumid];
					biomeMap[x+y*HM_WIDTH]=biome;
				}
			}
			float min,max;
			temperature.getMinMax(&min,&max);
			DBG( ("Temperatures min/max: %g / %g\n",min,max));			
		}

		TCODColor getBiomeColor(EBiome biome,int x,int y)
		{
		    static const TCODColor biomeColors[] = [
			    // TUNDRA,
			    TCODColor(200,240,255),
			    // COLD_DESERT,
			    TCODColor(180,210,210),
			    // GRASSLAND,
			    TCODColor.sea,
			    // BOREAL_FOREST,
			    TCODColor(14,93,43),
			    // TEMPERATE_FOREST,
			    TCODColor(44,177,83),
			    // TROPICAL_MONTANE_FOREST,
			    TCODColor(185,232,164),
			    // HOT_DESERT,
			    TCODColor(235,255,210),
			    // SAVANNA,
			    TCODColor(255,205,20),
			    // TROPICAL_DRY_FOREST,
			    TCODColor(60,130,40),
			    // TROPICAL_EVERGREEN_FOREST,
			    TCODColor.green,
			    // THORN_FOREST,
			    TCODColor(192,192,112),
		    ];
		    int r = 0, g = 0, b = 0, count = 1;
		    r += biomeColors[biome].r;
		    g += biomeColors[biome].g;
		    b += biomeColors[biome].b;
		    for (int i = 0; i < 4; i++ ) 
		    {
		        int ix = x+wgRng.getInt(-10,10);
		        int iy = y+wgRng.getInt(-10,10);
		        if ( IN_RECTANGLE(ix,iy,HM_WIDTH,HM_HEIGHT) ) 
		        {
		            TCODColor c = biomeColors[biomeMap[ix+iy*HM_WIDTH]];
		            r += c.r + wgRng.getInt(-10,10);
		            g += c.g + wgRng.getInt(-10,10);
		            b += c.b + wgRng.getInt(-10,10);
		            count++;
		        }
		    }
		    r /= count;
		    g /= count;
		    b /= count;
		    r = clamp(0,255,r);
		    g = clamp(0,255,g);
		    b = clamp(0,255,b);
		    return TCODColor(r,g,b);			
		}

		void computePrecipitations()
		{
		    static const float waterAdd = 0.03f;
		    static const float slopeCoef = 2.0f;
		    static const float basePrecip = 0.01f; // precipitation coef when slope == 0
			float t0=TCODSystem.getElapsedSeconds();
		    // north/south winds
		    for (int diry=-1; diry <= 1; diry += 2 ) 
		    {
		        for (int x=0; x < HM_WIDTH; x++) 
		        {
		            float noisex = cast(float)(x)*5/HM_WIDTH;
		            float waterAmount=(1.0f+noise1d.getFbmSimplex(&noisex,3.0f));
		            int starty = (diry == -1 ? HM_HEIGHT-1 : 0);
		            int endy = (diry == -1 ? -1 : HM_HEIGHT);
		            for (int y=starty; y != endy; y += diry) 
		            {
		                float h = hm.getValue(x,y);
		                if ( h < sandHeight ) 
		                {
		                    waterAmount += waterAdd;
		                } else if (waterAmount > 0.0f )
		                {
		                    float slope;
		                    if ( cast(uint)(y + diry) < cast(uint)HM_HEIGHT ) slope = hm.getValue(x,y+diry) - h;
		                    else slope = h - hm.getValue(x,y-diry);
		                    if ( slope >= 0.0f ) 
		                    {
		                        float precip = waterAmount * (basePrecip + slope * slopeCoef);
		                        precipitation.setValue(x,y,precipitation.getValue(x,y)+precip);
		                        waterAmount -= precip;
		                        waterAmount = cast(float)fmax(0.0f,waterAmount);
		                    }
		                }
		            }
		        }
		    }
			float t1=TCODSystem.getElapsedSeconds();
			DBG(("  North/south winds... %g\n", t1-t0 ));
			t0=t1;

		    // east/west winds
		    for (int dirx=-1; dirx <= 1; dirx += 2 ) 
		    {
		        for (int y=0; y < HM_HEIGHT; y++) 
		        {
		            float noisey = cast(float)(y)*5/HM_HEIGHT;
		            float waterAmount=(1.0f+noise1d.getFbmSimplex(&noisey,3.0f));
		            int startx = (dirx == -1 ? HM_WIDTH-1 : 0);
		            int endx = (dirx == -1 ? -1 : HM_WIDTH);
		            for (int x=startx; x != endx; x += dirx) 
		            {
		                float h = hm.getValue(x,y);
		                if ( h < sandHeight ) 
		                {
		                    waterAmount += waterAdd;
		                } else if (waterAmount > 0.0f )
		                {
		                    float slope;
		                    if ( cast(uint)(x + dirx) < cast(uint)HM_WIDTH ) slope = hm.getValue(x+dirx,y) - h;
		                    else slope = h - hm.getValue(x-dirx,y);
		                    if ( slope >= 0.0f ) 
		                    {
		                        float precip = waterAmount * (basePrecip + slope * slopeCoef);
		                        precipitation.setValue(x,y,precipitation.getValue(x,y)+precip);
		                        waterAmount -= precip;
		                        waterAmount = cast(float)fmax(0.0f,waterAmount);
		                    }
		                }
		            }
		        }
		    }
			t1 = TCODSystem.getElapsedSeconds();
			DBG(("  East/west winds... %g\n", t1-t0 ));
			t0=t1;

			float min,max;
			precipitation.getMinMax(&min,&max);

		    // latitude impact
			for (int y=HM_HEIGHT/4; y < 3*HM_HEIGHT/4; y++) 
			{
		        // latitude (0 : equator, -1/1 : pole)
		        float lat = cast(float)(y-HM_HEIGHT/4) * 2 / HM_HEIGHT ;
		        float coef = sinf(2*3.1415926*lat );
		        for (int x=0; x < HM_WIDTH; x++) 
		        {
		            float f[2] = [ cast(float)(x)/HM_WIDTH, cast(float)(y)/HM_HEIGHT ];
		            float xcoef = coef + 0.5f*noise2d.getFbmSimplex(f,3.0f);
		            float precip = precipitation.getValue(x,y);
		            precip +=  (max-min) * xcoef * 0.1f;
		            precipitation.setValue(x,y,precip);
				}
			}
			t1 = TCODSystem.getElapsedSeconds();
			DBG(("  latitude... %g\n", t1-t0 ));
			t0 = t1;

			// very fast blur by scaling down and up
			static const int factor=8;
			static const int smallWidth = (HM_WIDTH+factor-1)/factor;
			static const int smallHeight = (HM_HEIGHT+factor-1)/factor;
			float *lowResMap = new float[smallWidth * smallHeight];
			memset(lowResMap, 0, float.sizeof*smallWidth*smallHeight);
			for (int x=0; x < HM_WIDTH; x++) 
			{
				for (int y=0; y < HM_HEIGHT; y++) 
				{
					float v = precipitation.getValue(x,y);
					int ix = x/factor;
					int iy = y/factor;
					lowResMap[ix + iy*smallWidth ] += v;
				}
			}
			float coef = 1.0f/factor;
			for (int x=0; x < HM_WIDTH; x++)
			{
				for (int y=0; y < HM_HEIGHT; y++) 
				{
					float v=getInterpolatedFloat(lowResMap,x*coef,y*coef,smallWidth,smallHeight);
					precipitation.setValue(x,y,v);
				}
			}
		}

		void computeColors()
		{
			// alter map color using temperature & precipitation maps
			map_data_t *md = mapData;
			for (int y=0; y < HM_HEIGHT; y++) 
			{
		        for (int x=0; x < HM_WIDTH; x++) 
		        {
					float h = hm.getValue(x,y);
					float temp = temperature.getValue(x,y);
					EBiome biome = biomeMap[x+y*HM_WIDTH];
					TCODColor c;
					if (h < sandHeight ) c = getMapColor(h);
					else 
					{
						c = getMapColor(h);
		                c = TCODColor.lerp(c,getBiomeColor(biome,x,y),0.5f);
					}

					// snow near poles
					temp += 10*(clouds[HM_WIDTH-1-x][HM_HEIGHT-1-y]); // cheap 2D noise ;)
					if ( temp < -10.0f && h < sandHeight ) worldmap.putPixel(x,y,TCODColor.lerp(TCODColor.white,c,0.3f));
					else if ( temp < -8.0f && h < sandHeight ) worldmap.putPixel(x,y,TCODColor.lerp(TCODColor.white,c,0.3f + 0.7f * (10.0f+temp)/2.0f));
					else if ( temp < -2.0f && h >= sandHeight) worldmap.putPixel(x,y,TCODColor.white);
					else if ( temp < 2.0f && h >= sandHeight ) 
					{
						//TCODColor snow = mapGradient[cast(int)(snowHeight*255) + cast(int)((255 - cast(int)(snowHeight*255)) * (0.6f-temp)/0.4f)];
						c = TCODColor.lerp(TCODColor.white,c,(temp+2)/4.0f);
						worldmap.putPixel(x,y,c);
					} else 
					{
						worldmap.putPixel(x,y,c);
					}
					md++;
				}
			}
			// draw rivers
			/*
			for (river_t **it=rivers.begin(); it != rivers.end(); it++) 
			{
			    for (int i=0; i < (*it).coords.size(); i++ ) 
			    {
			        int coord = (*it).coords.get(i);
			        int strength = (*it).strength.get(i);
			        int x = coord % HM_WIDTH;
			        int y = coord / HM_WIDTH;
			        TCODColor c= worldmap.getPixel(x,y);
			        c = TCODColor.lerp(c,TCODColor.blue,(float)(strength)/5.0f);
			        worldmap.putPixel(x,y,c);
			    }
			}
			*/
			md=mapData;
			for (int y=0; y < HM_HEIGHT; y++) 
			{
		        for (int x=0; x < HM_WIDTH; x++) 
		        {
		            if ( md.riverId > 0 ) {
		                TCODColor c= worldmap.getPixel(x,y);
		                c = TCODColor.lerp(c,TCODColor.blue,0.3f);
		                worldmap.putPixel(x,y,c);
		            }
		            md++;
		        }
			}
			// blur
			static const int dx[]=[0,-1,0,1,0];
			static const int dy[]=[0,0,-1,0,1];
			static const int coef[]=[1,2,2,2,2];
			for (int x=0; x < HM_WIDTH; x++) 
			{
				for (int y=0; y < HM_HEIGHT; y++)
				 {
			        int r=0,g=0,b=0,count=0;
				    for (size_t i=0; i < 5; i++) 
				    {
				        int ix=x+dx[i];
				        int iy=y+dy[i];
				        if (IN_RECTANGLE(ix,iy,HM_WIDTH,HM_HEIGHT))
				        {
				            TCODColor c=worldmap.getPixel(ix,iy);
				            r += coef[i]*c.r;
				            g += coef[i]*c.g;
				            b += coef[i]*c.b;
				            count += coef[i];
				        }
				    }
		            r /= count;
		            g /= count;
		            b /= count;
		            worldmap.putPixel(x,y,TCODColor(r,g,b));
				}
			}
			drawCoasts(worldmap);
		}

		void drawCoasts(TCODImage *img)
		{
		    // detect coasts
		    for (int x=0; x < HM_WIDTH-1; x++) 
		    {
		        for (int y=0; y < HM_HEIGHT-1; y++) 
		        {
		            float h = hm.getValue(x,y);
		            float h2 = hm.getValue(x+1,y);
		            if ( ( h < sandHeight && h2 >= sandHeight )
		                || ( h2 < sandHeight && h >= sandHeight ) ) img.putPixel(x,y,TCODColor.black);
		            else 
		            {
		                h = hm.getValue(x,y);
		                h2 = hm.getValue(x,y+1);
		                if ( ( h < sandHeight && h2 >= sandHeight )
		                    || ( h2 < sandHeight && h >= sandHeight ) ) img.putPixel(x,y,TCODColor.black);
		            }
		        }
		    }			
		}

		EClimate getClimateFromTemp(float temp)
		{
		    if ( temp <= -5 ) return EClimate.ARTIC_ALPINE;
		    if ( temp <= 5 )  return EClimate.COLD;
		    if ( temp <= 15 ) return EClimate.TEMPERATE;
		    if ( temp <= 20 ) return EClimate.WARM;
		    return EClimate.TROPICAL;			
		}	
	}
}